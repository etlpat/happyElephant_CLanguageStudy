#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>



/////////////////        （题目1.）
/////////////////       分析sizeof()计算的数组和指针相关的大小
/////////////////       秘诀是分析处[数组名的意义是什么]


////数组名是首元素地址（仅有两个例外，其他所以数组名都是首元素地址）
////1.sizeof(数组名)
////2.&数组名
////声明两种情况，是死的，数组名的地方只能是数组名，不能进行任何操作，如+0


//int main()
//{
//	///////   一维数组
//
//
//	//////整形数组(sizeof())
//	//int a[] = { 1,2,3,4 };
//	//printf("%d\n", sizeof(a));         // 16  --  sizeof(数组名)，计算数组总大小，a是整个数组的地址
//	//printf("%d\n", sizeof(a + 0));     // 4/8 --  sizeof(a+0)斌不符合sizeof(数组名)的形式，a是首元素地址
//	//printf("%d\n", sizeof(*a));        // 4   --  a是首元素地址，*a是首元素
//	//printf("%d\n", sizeof(a + 1));     // 4/8 --  a+1是第二个元素地址
//	//printf("%d\n", sizeof(a[1]));      // 4   --  a[1]是整形
//	//printf("%d\n", sizeof(&a));        // 4/8 --  &a是数组的地址，地址大小就是4/8
//	//printf("%d\n", sizeof(*&a));       // 16  --  &a已经说明a是整个数组,再*&a还是数组
//	//printf("%d\n", sizeof(&a + 1));    // 4/8 --  &a是整个数组的地址，&a+1是跳过整个数组后的地址，但还是地址，4/8
//	//printf("%d\n", sizeof(&a[0]));     // 4/8 --  []优先级高，a[0]是首元素，&a[0]是地址
//	//printf("%d\n", sizeof(&a[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	//////字符数组(sizeof())
//	//char c[] = { 'a','b','c','d','e','f' };
//	//printf("%d\n", sizeof(c));         // 6   --  计算数组大小，每个字符1字节
//	//printf("%d\n", sizeof(c + 0));     // 4/8 --  地址+0还是地址，4/8
//	//printf("%d\n", sizeof(*c));        // 1   --  字符
//	//printf("%d\n", sizeof(c[1]));      // 1   --  字符
//	//printf("%d\n", sizeof(&c));        // 4/8 --  数组的地址，还是地址4/8
//	//printf("%d\n", sizeof(&c + 1));    // 4/8 --  &c是整个数组的地址，&c+1跳出了数组，但还是地址，4/8
//	//printf("%d\n", sizeof(&c[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	//////字符数组(strlen())
//	////strlen()计算模式：从地址起始位置开始，向后1字节1字节的找，直到找到'\0'停止，长度不包含'\0'
//	//char c[] = { 'a','b','c','d','e','f' };
//	//printf("%d\n", strlen(c));         // 随机值 --  c是首元素地址，从首元素开始向后数
//	//printf("%d\n", strlen(c + 0));     // 随机值 --  和上一个完全相同
//	////printf("%d\n", strlen(*c));      // 非法访问 --  strlen接收地址，'a'-97，把97转换为地址访问，但是内存中没有这块空间，非法访问
//	////printf("%d\n", strlen(c[1]));    // 非法访问 --  同上
//	//printf("%d\n", strlen(&c));        // 随机值 --  和上面随机值相同
//	//printf("%d\n", strlen(&c + 1));    // 随机值 --  比上面随机值少6，跳过了一个数组
//	//printf("%d\n", strlen(&c[0] + 1)); // 随机值 --  比上面随机值少1
//
//
//	//////字符串(sizeof())
//	//char c[] = "abcdef";
//	//printf("%d\n", sizeof(c));         // 7   --  计算字符串所占空间大小，与是否是'\0'无关
//	//printf("%d\n", sizeof(c + 0));     // 4/8 --  不符合sizeof(数组名)形式，是地址
//	//printf("%d\n", sizeof(*c));        // 1   --  字符
//	//printf("%d\n", sizeof(c[1]));      // 1   --  字符
//	//printf("%d\n", sizeof(&c));        // 4/8 --  数组的地址，还是地址
//	//printf("%d\n", sizeof(&c + 1));    // 4/8 --  &c是整个数组的地址，&c+1跳出了数组，但还是地址
//	//printf("%d\n", sizeof(&c[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	//////字符串(strlen())
//	//char c[] = "abcdef";
//	//printf("%d\n", strlen(c));         //   6      --  strlen()遇'\0'停止
//	//printf("%d\n", strlen(c + 0));     //   6      --  和上面同理
//	////printf("%d\n", strlen(*c));      // 非法访问 --  strlen接收地址，'a'-97，不是地址
//	////printf("%d\n", strlen(c[1]));    // 非法访问 --  相当于传了98并将其转化为地址，但内存中并无98这块空间
//	//printf("%d\n", strlen(&c));        //   6      --  strlen从起始位置开始计数，数组地址起始位置和首元素地址起始位置相同；
//	////                                                ////#但是这里会警告：因为strlen()参数默认类型为const char* ，但是这里&c传递的是数组地址char(*c)[7]，警报类型不兼容
//	////                                                ////但是传递过去自动强制类型转换，二者起始位置相同，结果仍然相同
//	//printf("%d\n", strlen(&c + 1));    // 随机值   --  跳出字符串，遇到'\0'的地点未知；且和上一个一样，有警告
//	//printf("%d\n", strlen(&c[0] + 1)); //   5      --  地址+1，少一个元素 
//	//printf("\n");
//
//
//	////////常量字符串(sizeof())
//	////直接用一个指针接收一个字符串时，该字符串是个常量字符串，不能改变；指针存放常量字符串的首元素地址
//	//char* p = "abcdef";
//	//printf("%d\n", sizeof(p));         // 4/8 --  p是常量字符串的首元素地址
//	//printf("%d\n", sizeof(p + 1));     // 4/8 --  地址+1，还是地址
//	//printf("%d\n", sizeof(*p));        // 1   --  a字符
//	//printf("%d\n", sizeof(p[0]));      // 1   --  a字符，p[0]==*(p+0),[]适用于所有指针
//	//printf("%d\n", sizeof(&p));        // 4/8 --  二级指针，还是地址
//	//printf("%d\n", sizeof(&p + 1));    // 4/8 --  二级指针+1，还是地址
//	//printf("%d\n", sizeof(&p[0] + 1)); // 4/8 --  地址+1，还是地址
//	//printf("\n");
//
//
//	////////常量字符串(strlen())
//	//char* p = "abcdef";
//	//printf("%d\n", strlen(p));         // 6
//	//printf("%d\n", strlen(p + 1));     // 5 
//	////printf("%d\n", strlen(*p));      // 非法访问 
//	////printf("%d\n", strlen(p[0]));    // 非法访问
//	//printf("%d\n", strlen(&p));        // 随机值 --  p是地址,假设为0x0112ff46，&p是p的地址，strlen(&p)是把地址p当作字符串来计算，由于地址小端存储，所以计算 46 ff 12 01，之后就是随机值，知道遇到'\0'==0就停止
//	//printf("%d\n", strlen(&p + 1));    // 随机值
//	//printf("%d\n", strlen(&p[0] + 1)); // 5
//	//printf("\n");
//
//
//	return 0;
//}

//int main()
//{
//	///////   方法还是和上面一样，sizeof(数组名)/&数组名，数组名才代表整个数组，其他时候都代表首元素 地址
//	// /////
//	///////   二维数组：
//	///////   假如int a[3][3]={{1,2,3},{4,5,6},{7,8,9}};
//	///////   第一行元素a[0][i]，第二行元素a[1][i]，第三行元素a[2][i]，所以a[0]、a[1]、a[2]可看作每行数组的数组名
//	///////   因为二维数组的三个元素是a[0]、a[1]、a[2]，所以二维数组每给个元素是一个一维数组
//
//
//	int a[3][4] = { 0 };
//	printf("%d\n", sizeof(a));             // 48
//	printf("%d\n", sizeof(a[0][0]));       // 4
//	printf("%d\n", sizeof(a[0]));          // 16  -- a[0]是二维数组首元素，是第一行一维数组的数组名，数组名单独放到sizeof()中，计算的是数组大小
//	printf("%d\n", sizeof(a[0] + 1));      // 4/8 -- a[0]不是单独放在sizeof()内部，那么数组名a[0]就代表首元素地址
//	printf("%d\n", sizeof(*(a[0] + 1)));   // 4   -- 同上方法数组名+1相当于首元素地址+1；或者直接相当于a[0][1]
//	printf("%d\n", sizeof(a + 1));         // 4/8 -- a是二维数组名，a+1相当于第二个一维数组的地址
//	printf("%d\n", sizeof(*(a + 1)));      // 16  -- 第二行的地址解引用相当于第二行，相当于数组；或者直接a[1]
//	printf("%d\n", sizeof(&a[0] + 1));     // 4/8 -- 第二行的地址
//	printf("%d\n", sizeof(*(&a[0] + 1)));  // 16  -- 第二行的大小
//	printf("%d\n", sizeof(*a));            // 16  -- 首元素解引用，就是第一行
//	printf("%d\n", sizeof(a[3]));          // 16 #坑# 因为sizeof()内的表达式不会真实计算，只是根据类型计算大小，所以a[3]和a[0]没区别
//
//
//	return 0;
//}















////////////////////////////////        指针笔试题
//////写代三码境界：1.看代码是代码 2.看代码是内存 3.看代码是代码




//////////   （笔试题1）
//int main()
//{
//	int a[5] = { 1,2,3,4,5 };
//	int* ptr = (int*)(&a + 1);//&a+1表示跳过整个数组的地址，然后强转为(int*)
//	printf("%d,%d", *(a + 1), *(ptr - 1));//2,5
//	return 0;
//}
// 
//////考点：&数组名 是整个数组的指针






//////////   （笔试题2）
//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa;
//}*p;
//
////假设p的值为0x100000。如下表达式的值分别是多少？
////已知结构体Test类型变量的大小是20个字节 
//int main()
//{
//	printf("%p\n", p + 0x1);//这个结构体20字节，所以结构体指针+1，指针跨度为20，为 0x100000 + 0x14 -> 0x100014；若是32位机，地址是00100014
//	printf("%p\n", (unsigned long)p + 0x1);//0x00100000，类型为整型，0x00100000 + 0x1 -> 0x00100001             若是32位机，地址是00100001
//	printf("%p\n", (unsigned int*)p + 0x1);//0x00100000，整形指针+1，跨度为4指针，0x100000 + 0x4 -> 0x100004    若是32位机，地址是00100004
//	return 0;
//}
//
//////考点：
//////1地址对应1字节；int a有4个字节，a的地址以第一个字节的指针表示
//////指针+-整数，跨度取决于指针类型 







////////////   （笔试题3）
///////题目：
// int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//	printf("%x\n", ptr1[-1],*ptr2);
//	return 0;
//}
//
////////解释如下：
//
//int main()
//{
//	int a[4] = { 1,2,3,4 };
//	int* ptr1 = (int*)(&a + 1);//&a+1表示跳过整个数组的(int*类型)地址
//	int* ptr2 = (int*)((int)a + 1);//结果相当于(int*)((char*)a+1)
//	int* ptr3 = (int*)((char*)a + 1);//同上
//
//	//// 数组a在内存中（小端存储）
//	//// 内存中，最小的内存单位是1个字节，每个字节都对应一个地址，那么两个相邻（值相差1）的地址之间差1个字节
//	//// | 01 00 00 00 | 02 00 00 00 | 03 00 00 00 | 04 00 00 00 |
//	////    |#00 00 00   02|    
//	// 
//	//// ptr2的解释
//	//// a为数名(首元素地址)，是指向上面01处的地址，假设a的地址是0x0012ff05
//	//// 地址a强制类型转化为(int)型，是个整数，(int)a + 1 = 0x0012ff06 
//	//// 0x0012ff05与0x0012ff06之间差了1，对应回内存中相差了1字节，0x0012ff06指向内存中01后面的一个字节00（上面#处）
//	//// ptr2为(int*类型)，可访问4个字节，在内存中对应（小端的）00 00 00 02，值就是0x 02 00 00 00
//
//	printf("%x\n", ptr1[-1]);//4
//	printf("%x\n", *ptr3);//2000000
//	printf("%x\n", *ptr2);//2000000，解释如上，但是本编译器中不能运行
//	return 0;
//}
//////考点：
////// 内存中，最小的内存单位是1个字节，每个字节都对应一个地址，那么两个相邻的地址之间差1个字节







////////////   （笔试题4）
//int main()
//{
//	int a[3][2] = { (0,1),(2,3),(4,5) };//{{1,3},{5,0},{0,0}}
//	int* p;
//	p = a[0];
//	printf("%d\n", p[0]);//1
//	return 0;
//}
////////考点：
////////圆括号里是逗号表达式，结果是最后一个表达式的结果







////////////   （笔试题5）
///////题目：
//int main()
//{
//	int a[5][5];
//	int(*p)[4];
//	p = a;
//	printf("%d\n%p\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//	return 0;
//}
//
////////解释如下：
//
//int main()
//{
//	int a[5][5];
//	int(*p)[4]; 
//	p = a;
//
//	// a                                                                          #:a[4][2]
//	//{ {1, 2, 3, 4, 5},{1, 2, 3 , 4, 5 },{1, 2, 3, 4, 5 },{1, 2, 3, 4, 5 }, { 1, 2, 3, 4, 5 } }
//	//{ {1, 2, 3, 4}{5,  1, 2, 3,}{4, 5 ,  1, 2}{3, 4, 5,   1}{2, 4, 4, 5 }, { 1, 2, 3, 4}
//	// p                                                          #:p[4][2]
//
//	printf("%d\n%p\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//-4,FFFFFFFC
//
//	//(&p[4][2]-&a[4][2])值为-4（之间差4个元素）
//	//%p打印-4 ,直接将-4补码的十六进制作为地址打印
//	//-4 = 10000000 0000000 00000000 00000100(原) == 11111111 11111111 11111111 11111100(补) == 0x FF FF FF FC
//
//	return 0;
//}
////////考点：
////////指针加减k就是跳过k个指针类型的单位长度，同理，指针+-指针，就是两指针差的元素个数；例如(int*)16-(int*)0 == (16-0)/sizeof(int) == 16/4 ==4







////////////   （笔试题6）
///////题目：
//int main()
//{
//	int aa[2][5] = { 1,2,3,4,5,6,7,8,9,10 };
//	int* ptr1 = (int*)(&aa + 1);//10
//	int* ptr2 = (int*)(*(aa + 1));//5
//	printf("%d,%d\n", *(ptr1 - 1), *(ptr2 - 1));
//	return 0;
//}
////////考点：
////////关注数组名的含义







////////////   （笔试题7）
///////题目：
//int main()
//{
//	char* a[] = { "work","at","alibaba" };
//	char** pa = a;
//	pa++;
//	printf("%s\n", *pa);
//	return 0;
//}
//
////////解释如下：
//
//int main()
//{
//	char* a[] = { "work","at","alibaba" };//元素为字符串首字符地址，也可以看作字符串的数组名
//	//数组a中存了3个(char*)指针，一个指向'w'(work)，一个指向'a'(at)，一个指向'a'(alibaba)
//
//	char** pa = a;// char*(*pa),pa是个首元素地址，指向元素类型是char*
//	pa++;//pa指向char*的变量，所以pa+1跳过一个char*
//	printf("%s\n", *pa);//at  %s以pa的地址为开头，找到'\0'停止
//	return 0;
//}







////////////   （笔试题8）#重难点#
///////题目：
//int main()
//{
//	char* c[] = { "ENTER","NEW","POINT","FIRST" };
//	char** cp[] = { c + 3, c + 2, c + 1, c };
//	char*** cpp = cp;
//	printf("%s\n", **++cpp);
//	printf("%s\n", *-- * ++cpp + 3);
//	printf("%s\n", *cpp[-2] + 3);
//	printf("%s\n", cpp[-1][-1] + 1);
// 	printf("%s\n", (*cpp)[+1] + 1);
//	return 0;
//}
//
////////解释如下：
//
//int main()
//{
//	char* c[] = { "ENTER","NEW","POINT","FIRST" };//c中4个字符指针，指向4个字符串的首字符地址
//	char** cp[] = { c + 3, c + 2, c + 1, c };//cp中4个字符指针的指针，分别指向上面数组中元素地址
//	char*** cpp = cp;//cpp是cp的首元素地址
//
//	//单目操作符优先级高于双目操作符
//	printf("%s\n", **++cpp);//**++cpp -> *(c+2) == 【POINT】 ; 注意这里cpp的值已+1，会影响后面的结果。cpp指向cp[1]
//	printf("%s\n", *-- * ++cpp + 3);//*--*++cpp+3 -> *--cp[2]+3 -> {cp[2]中原本放的内容自减，变成c} -> *c+3 == c[0]+3 == 【ER】 ; c[0]是ENTRE中E的地址 ;cpp指向cp[2]; cp[2]中内容变为c
//	printf("%s\n", *cpp[-2] + 3);//*cpp[-2] + 3 -> **(cpp-2)+3 -> *(c+3)+3 -> c[3]+3 == 【ST】 ;c [3]是FIRST中F的地址 ;cpp指向cp[2]
//	printf("%s\n", cpp[-1][-1] + 1);//*(*(cpp-1)-1)+1 -> 方法同上 //【EW】 
//	printf("%s\n", (*cpp)[+1] + 1);//*(cp[2]+1)+1 -> *(c+1) + 1 //【EW】;这里注意 cpp指向cp[2]，cp[2]的值之前变为c
//	return 0;
//}
////////考点：
////////注意 ++ -- 的副作用，会导致前面的值发生改变，后面的运算要在改变以后的1基础上进行计算
////////分析指针指向的对象到底是什么
////////做题方法：
////////    画图法，把内存中的图像画出来
