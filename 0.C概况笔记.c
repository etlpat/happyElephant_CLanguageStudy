//#define _CRT_SECURE_NO_WARNINGS 1
// 
// 
// 
// 
//c代码
//.c源文件
//.h头文件  h = head
//
// 
// 
// 
//
//
//main函数，(主函数 - 程序的入口)
//程序开始运行的地方，有且仅有一个
//
//
//
//int
//整数integer的缩写。
//在这里，int是整型的意思。
//main函数前面的int，说明这个main函数的返回值是int（整数）型  ，和下面return 0呼应。
//
// 
//返回值：子程序或者函数执行结束后返回给主程序或者调用函数的函数的值
//return 0 代表程序正常退出，返回到主程序继续往下执行。
// 
// 
// 
// 
//printf = print fuction(打印函数)
//printf("% c\n"，ch)是固定格式
//意思是“我以字符的形式打印ch”
//
// 
// 
// 
//#include  <studio.h>
//意思是包含一个叫studio.h的文件
//因为下面主函数中调用了库函数，这里相当于是在打招呼，要调用库函数
//
// 
// 
// 
//stdio.h(标准输入输出头文件)
//std = standard(标准)   i = input  o = output
//.h = 头文件
//
//
//
//
//
//
//数据类型
//作用是向内存申请空间来创建变量
//% d―打印整型
//% c―打印字符
//% f―打印浮点数字―打印小数
//% lf―打印双精度浮点数，精度比% f高
//
//
// 
//
//1、字符’A’要用单引号，数字不用
//
// 
// 
//
//char 变量 = ’A’
//意思是向内存申请一个字节间存放字符A，
// 
//
//
// 
//
//3、 % d――打印整型十进制的数据
//      十进制英文：Denary
//
//
//
//
//但是
//float num = 10.3f
//若不加f，有的编译器可能认为10.3是双精度浮点数，会报错
//double num = 10.3，这是正确的
//
//
//
//
//
//计算机是硬件―通电
//正电：1   负电：0
//
//计算机中的单位
//bit――比特位  （1或0占一个比特位）
//byte――字节（一个字节 = 八个比特位）
//kb――1024字节
//mb――1024kb
//gb――1024mb
//tb――1024gb
//pb――1024tb
//
//一个short占2个字节 = 16个比位， 可表示2 ^ 16个数字，数字范围是（0，2 ^ 16 - 1）
//
// 
// 
//为什么要分数据类型？
// 
//由于short可表示数字区间为（0，2 ^ 16 - 1）
//int可表示数字区间为（0，2 ^ 32 - 1）
// 因为
//short age = 20   是0000000000010100
//int age = 20     是0000000000000000000000000000010100
//显然short更节省空间
// 
// 
// 
// 
//char ch = ’A’
//意思为：向内存申请1个字节存放字符A
//int number = 20
//意思为：向内存申请4个字节存放整数2
//
//
//
// 
//定义变量：数据类型加变量名再赋值
//char ch = ’A’
//int number = 20
//float num = 10.3f
//
// 
// 
//
//  全局变量、局部变量
//
//全局变量：定义在代码块（｛｝）外的变量
//局部变量：定义在代码块（｛｝）内的变量
//局部变量与全局变量名字相同时，局部变量优先
//
// 
//全局变量a   在哪都能用
//局部变量b   不能在其范围外使用
//
//
//
//
//
//
// & :取地址:获取变量的地址
//地址：在计算机中, 标识寄存器、存储单元和存储设备的编号或名称（内存中数据的编号）
//
//
//
//int num1 = 0
//int num2 = 0        放主函数最前边
//int sum = 0
//C语言语法规定，变量要定义在当前代码块的最前面
//
// 
// 
//
//scanf（）:输入函数
//要被声明在头文件stdio.h里
//它是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中。
//
// p.s.VS编译器有时候让用scanf_s，此时不要用，因为不具有跨平台性，其他编译器不认scanf_s
// 那么想解决问题可以加上如下，从报错提示中复制，加在源文件的第一行
//
//
//
//
//作用域
//名字哪里可以用，哪里就是它的作用域
// 
//局部变量作用域在其所在代码块的内部
//同理，全局变量的作用域是整个工程
//
// 
// 
// 
//生命周期
//局部变量生命周期，进作用域开始，出作用域结束（局部变量只在其所在的｛｝中有用）
//全局变量生命周期是整个程序的生命周期
//
//
//
//
// 
//常变量
//int num = 3，num为变量
//
// 
//    常量1、字面常量
//        e.g.普通数字5
//
// 
// 
//    常量2、const修饰的常变量
// 
//        #include<stdio.h>
//        int main()
//        {
//        const int num = 4;
//        printf(“ % d\n”，num);
//        num = 8;
//        printf(“ % d\n”，num);
//        return 0;
//        }
//        结果会报错
//
//        因为const指的是常属性
//        这里int num前加const，num就是const修饰的常变量。前面num赋值是4，后面就不能在赋值8了
//        (本质是变量，但有常属性，在要使用常量的地方不能用)
//
// 
//        
// 
//    常量3、#define 定义的标识符常量
//        
//        #include<stdio.h>
//        #define A 10
//        int main()
//        {
//        printf（“d% \n”，A）;
//        return 0;
//        }
//        打印结果是 10，这种方式A本质变为常量
//
// 
// 
// 
//    4、枚举常量
//        枚举关键词 ― enum（枚举的英文）
//        用法如下
//     
//        #include<stdio.h>
//        enum Color
//       {
//        Red，
//        Yellow，       左边是枚举常量
//        Blue
//        };
//       int main()
//       {
//        enum Color A = Blue;
//        …
//            return 0;
//       }
//   
//        1、若上面printf(“ % d\n”，Red)
//        printf(“ % d\n”，Yellow)
//        printf(“ % d\n”，Blue)
//        则输出 0   1   2
//        枚举常量是有值的，且固定是0 1 2…
//
//        2、上面若在…加上A = Yellow.，也是可以的，A是变量，可改，是Yellow本身不能改
//
//
//
// 
//
//
//                        字符串
// 字符串：由双引号引起来的一串字符，单引号引起来的叫字符
// e.g.“abcdef”  ，“”是空字符串（类比空集）
// ’a’是字符
//注：字符串的结束标志是一个\0的转义字符。在计算字符串长度时，\0是结束标志，不算作字符串的内容
// 
// 
// 
// 
//“abc”比｛’a’，’b’，’c’｝多一个0
//    
// char arr1[] = “abc”;
// char arr2[] = { ’a’，’b’，’c’，0 };
// printf(“% s\n”，arr1[]);
// printf(“% s\n”，arr2[]);
//   如果在arr2中加0，则打印结果均为abc
// 
//
//这是因为“abc”中含’a’，’b’，’c’，’\0’
//’\0’为字符串结束标志，也是一个字符，\0值是0
//上面char arr2[] = { ’a’，’b’，’c’ }; 无’\0’做完结束标志，代码一直往后打印随机值
//
//
// 
// 
// 
//
//string
//  n.线，细绳；一连串，一系列；字符串
//  v.用线穿，串起
//计算字符串长度：strlen = string length
//要引头文件#include<string.h>
// 
//#include<stdio.h>
//#include<string.h>
//        int main()
//    {
//        char arr1[] = "abc";
//        char arr2[] = { 'a','b','c'};
//        printf(" % d\n",strlen(arr1));
//        printf(" % d\n",strlen(arr2));
//        return 0;
//    }
// 
//   最后输出结果为        3
//                       随机数
//
// \0是结束标志，strlen不会算其长度,所以“abc长度是3”
//char arr2[] = { ’a’，’b’，’c’ }，strlen计算完c后，因为没结束标志，后面是随机数，所以直到随机数为0时才会停止，因此长度随机
//
//
//
//
// 
// 
// 
// 转义字符
// 转变原来的意思
//
//\n为转移字符，把n变成了换行
//
//同理，\t――水平制表符
//输入\t，输出时在其位置加好几个空格    
//    例子如下
// printf(“\test”)，输出:               est
//        
// 
//printf(“\\test”)，输出\test
//转义字符算一个字符，如\t \233都是一个字符
//
// 
// 
// 
//若想要打印出一个  ’
//printf(“ % c\n”，’’’)     报错
//printf(“ % c\n”，’\’’)     ，输出 ’
// \’表示字符常量单引号
//
//同理，若要用字符串形式打印双引号也要加\
// printf(“ % s\n”，“\“”)     ，输出 “
//
//
// 
// 
//若\ddd.，ddd表示1～3个八进制数字
//如\32，八进制32 = 十进制3 * 8 ^ 1 + 2 * 8 ^ 0 = 26，结果打印出ASCII表中26对应的字符
//32― > 十进制26― > 做完ASCII表中代表的字符
// 
//\xdd十六进制同理
//
// 
// 
// 
//
//注释
//C语言注释风格：/*xxxxxxxxx*/，不能嵌套
//C++风格的注释：//xxxxxxxxxxx，可以注释一行或多行
//
//
//
// 
// 
// 
// 
// 
// 
// 
//        if算法初识
//      
//#include<stdio.h>
//        int main()
//    {
//        int input = 0;
//        printf(“进入大学\n”);
//        printf(“你要好好学习吗？（1 / 0) > :”);
//        scanf(“ % d”， & input);
//        if (input == 1)
//            printf（“好offer”\0）
//        else
//            printf(“卖红薯” \0)
//            return 0;
//    }
// 
//        1、 == ：判断相不相等
//
//
// 
// 
//
//        循环语句初识
//      
//#include<stdio.h>
//        int main()
//    {
//        int line = 0;
//        printf(“学习编程\n”);
//        while (line < 20000)
//            ｛
//            printf(“敲一行代码： % d\n”，line);
//        line++;
//        ｝
//            if (line >= 20000)
//                printf(“成为大牛\n”);
//        return 0;
//    }
//   
//
//
// 
//
//        自定义函数初识
//       
//#include<stdio.h>
//        int ADD(int x ，int y)
//    {
//        int z = x + y;
//        return z;
//    }
//
//    int main()
//    {
//        int num1 = 10；
//            int num2 = 20；
//            int sum = 0; e
//            sum = ADD(num1, num2);
//        printf(“sum = % d\n”，sum);
//        return 0;
//    }
//
// 
// 
// 
// 
// 
// 
// 
//
//
//    数组
//        int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
//                 下标： 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
//
// 数组：向内存申请一整块空间存放这十个数
//        array    n.一系列，大量；数组
//printf("%d\n"，arr[4])，即打印数组中下标是4的元素“5”
//

//
//
//
//
//
//
//        操作符
//
//        移位操作符： << , >>
//        转换成二进制以后挪移
//        int a = 3，a << 1 or a >> 1
//        0011(3)  变成  0110(6)  或者  0001(1)
//
// 
//        & :按位与      二进制中，两个数都是1，则输出1，否则输出0
//        101 & 011 = 001
//
//        | ：按位或     二进制中，有1就输出1，否则输出0
//        101 | 011 = 111
//
//        ^ ：按位异或        二进制中，两数相同输出0，不同则为1
//        101 ^ 011 = 110
//
// 
//        \除 %按位余
//        5÷2 = 2余1
//        5\2 = 2     5 & 2 = 1
//
// 
//        赋值操作符
//        = 赋值 == 判断是否相等
// 
// 
//        复合赋值符
//        a += 10 相当于 a = a+10
//        a -= 10 相当于a = a-10
//        a &= 2 相当于a = a & 2
//        a >>= 1相当于a = a >> 1
//
// 
// 
// 
// 
//        单目操作符
// 
//        !逻辑反操作
//        0 - 假，非0 - 真
//
// 
//        -：负号
//
// 
//        sizeof :计算变量 / 数组 / 类型所占空间，单位是字节  
//        sizeof(a)   sizeof a   sizeof(int)
//        不能 sizeof int
//
//
//        ～：按（2进制）位取反
//        a = 01010
//        b = ~a  b = 10101
//
//
//        int a = 10
//        int b = a++（a--）(先使用，后++ or --)
//
//        以上，b先变为a原来的值10，a再++变成11(9)
//
//        相反，int b = ++(--)a(先++ or --，后使用)
//        若a原本是10，则输出11  11(9  9)
//
//
//        （类型）强制类型转换
//        int a = (int)2.22
//        这样原本double的2.22就转成了int
//
// 
//        关系操作符
//        >
//        >=
//        <
//        <=
//        !=        用于测试不相等
//        ==        用于测试相等
//
//
//        逻辑操作符
//        && 逻辑与
//        || 逻辑或
//
//        C语言中：0是假       非0是真
//
//        && 逻辑与
//        判断二者是否为真，均为真，输出真（1）
//        || 逻辑或
//        判断二者有没有真，若有真，输出真（1）
//
//
//        exp：expression(表达式)
//        条件操作符 / 三目操作符
//        exp1 ？ exp2 : exp3
//        以上的意思为：
//        判断表达式1成立吗？
//        若成立，执行表达式1；
//        若不成立，执行表达式2
//
//
//        [] :下标引用操作符
//        arr[4]
//
// 
//        () : 函数调用操作符
//        int Add(int x, int y)
//    {
//        int z = x + y;
//        return z;
//    }
//    int sum = Add(a，b);       在此处调用了自定义函数
// 
// 
//       .       结构体变量.成员
//       ->      结构体指针->成员
//
//
//
//
//
//
//        原码，反码，补码
//
//        符号位(最左边一位)
//        1代表 - 0代表 +
//        [1][][][][][][][][][][][][][][][][][]
//        [0][][][][][][][][][][][][][][][][][]
//
//        原码：直接按照正负（1 / 0）写出的二进制序列
//        反码：原码的符号位不变，其他位按位取反
//        补码：反码 + 1
//
//        1 2 4 8 16 32
//        g. - 39
//
//        原码：1（…后面共32个bit）
//        1 000……000100111
//        反码：1 111……111011000
//        补码：1 111……111011001
//
//
//        关键词
//        typedef--类型重定义
//        type : 类型
//        如，原本需要用 unsigned int num = 20
//        现在可以 typedef unsigned int u - int
//        u - int num = 20
//
//
//        static
//        1、修饰局部变量，使其生命周期变长
//        若无static，出了a所在的括号，a的值就被删除；加上static后，出括号又进去时，a上一次的赋值仍被保留
//        ―――――――――――――
//        void pri()
//    {
//        static int a = 2;
//        a += 2;
//        printf("a = %d\n", a);
//    }
//
//    int main()
//    {
//        int i = 0;
//        while (i <= 8)
//        {
//            pri();
//            i++;
//        }
//            return 0;
//    }
//    ――――――――――――
//
//
//
//        extern : 声明外部符号或外部函数
//    在一个源文件中，声明另一个源文件中的全局变量或函数，使其在这里也可使用
//
//
//        static：修饰全局变量，改变变量的作用域和函数的链接属性（外部链接属性变内部链接属性）
// 
//        原本全局变量或函数只要声明，就可在全部源文件中使用
//        static，让静态的全局变量或函数只能在其自己的源文件内部使用
//
//
//
//
//
//
//
//        define:
//        1.定义标识符常量   #define MAX 100
//        2.可以定义宏-带参数    #define MAX(x, y) (x>y?x:y)
//
//
//
//
//
//
//             打印地址   %p:pointer    n.指针；指示器
//       虽然int是四个字节，理论上打印四个地址，但是计算机只会取首地址，打印出来是十六进制
//int main()
//{
//int a = 32;
//printf("%p\n", &a);
//return 0;
//}




//
//
//
//
//
//指针
// 
//
//如何产生地址？
//32位（32根地址线 / 数据线）
//正电（1） 和   负电（0）
//
//有2 ^ 32种排列方式
//00000000000000000000000000000000
//00000000000000000000000000000001
//00000000000000000000000000000010
//………
//11111111111111111111111111111111
//
//所以32位电脑，其地址有2 ^ 32种
//
//假设每个地址对应一个bit（比特位）
//已知1024 = 2 ^ 10
//2 ^ 32bit÷8÷2 ^ 10÷2 ^ 10÷2 ^ 10 = 0.5gb
//若1地址对应1bit，则电脑只有0.5G，不合适
//若1地址对应1字节，为4G空间，合适
//
// 
// 
// 
//
//打印地址 % p
//虽然int是四个字节，理论上打印四个地址，但是计算机只会取首地址
// 
////int main()
////{
//// int a = 32;
//// printf("%p\n", &a);
//// return 0;
////}
//
// 
//int* 是向内存申请空间存放地址的数据类型
//（也可能是char * short* float* 等）
//
//
////int main()
////{
//// int a = 32;
//// int* m//(指针变量） = &a;
//// printf("%p\n", m);
//// return 0;
////}
//
//
//* : 解引用操作符 / 间接访问操作符
//这里的 * p, 是将p(a的地址)解引用为a
//通过对p解引用操作，找到了p(&a)指向的对象
// 
//int main()
//{
//    int a = 108;
//    int* p = &a;
//    ////printf("%p\n", p);
//    *p = 23;
//    printf("%d", a);
//    return 0;
//}
//最后输出a = 23
//
// 
//p.s.只要机器是32位，不管是什么，其地址（指针变量）都是4个字节
//double d = 3.14，double * pd = &d
//虽然double是8字节，但其地址仍是有32个1或0构成，所以地址仍是4个字节
//也就是说，char*   int*   short* ...... 大小均是4
//
//
//
//
//
//
//
//
//
//
////////////////////                         结构体类型 
//////////////////                     struct:构建结构数组    
//
//struct BOOK
//{
//	char name[20];
//	float price;
//};
//int main()
//{
//	struct BOOK b = { "C语言程序设计" , 59.8f};
//	printf("书名是《%s》\n", b.name);
//	printf("价格是：%f\n", b.price);
//    return 0;
//}
//
//
//
// 
//
//
////////////////////                 结构体类型中指针的使用
// 
//////////////////////            .     结构体变量.成员
//////////////////////            ->    结构体指针->成员
// 
//struct A
//{
//	char no1[15];
//	int no2;
//};
//int main()
//{
//	struct A No = { "abcde",123 };
//	struct A* pNo = &No;
//	printf("%s\n",( * pNo).no1);
//	printf("%d\n",( * pNo).no2);
//	printf("%s\n", pNo->no1);
//	printf("%d\n", pNo->no2);
//	return 0;
//}
//
//
// 
// 
//
//
//////////////////              strcpy-string copy-字符串拷贝(库函数)-string.h
//////////////////              作用是可以改变数组的内容
//struct cc
//{
//	char a[23];
//	int b;
//};
//int main()
//{
//	struct cc qwer = { "12345",12 };
//	printf("%d\n", qwer.b);
//	qwer.b = 123;
//	printf("%d\n", qwer.b);
//	printf("%s\n", qwer.a);
//	strcpy(qwer.a, "45678");
//	printf("%s\n", qwer.a);
//	return 0;
//}
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








  //////选择语句



///////////////                  本质是：如果表达式结果为真（非0），则语句执行
//#include<stdio.h>
//int main()
//{
//	int age;
//	scanf("%d", &age);
//	if (age < 18)
//		printf("未成年\n");
//	else if (age >= 18 && age < 30)
//		printf("青年\n");
//	else if (age >= 30 && age < 50)
//		printf("壮年\n");
//	else if (age >= 50 && age <= 90)
//		printf("老年\n");
//	else
//		printf("??\n");
//	return 0;
//}
////或者
//int main()
//{
//	int age;
//	scanf("%d", &age);
//	if (age < 18)
//		printf("未成年");
//	else
//	{
//		if (age >= 18 && age < 30)
//			printf("青年");
//		else
//		{
//			if (age >= 30 && age<50)
//				printf("壮年");
//			else
//			{
//				if (age >= 50 && age < 90)
//					printf("老年");
//				else
//					printf("??");
//			}
//		}
//	}
//	return 0;
//}


//////////         如果条件成立，若要执行多条语句，则应使用代码块
// //////          if else 整体算一个语句
//int main()
//{
//	int i;
//	scanf("%d", &i);
//	int a = 0;
//	if (i < 3)
//	{
//		i++;
//		a += 2;
//	}
//	else
//	{
//		i--;
//		a -= 2;
//	}
//	printf("%d,%d", i, a);
//	return 0;
//}
//
//
/////////////////                   else 匹配的是离他最近的未被匹配的 if
////////////////                    如下，看似打印hhhhh，确实什么也打不了
//int main()
//{
//	int a = 0;
//	int b = 2;
//	if (a == 1)
//		if (b == 2)
//			printf("hh");
//	else
//	printf("hhhhhh");
//	return 0;
//}
//
//
//int main()
//{
//	int a = 0;
//	int b = 2;
//	if (a == 1)
//		if (b == 2)
//			printf("hh");
//		else
//			printf("hhhhhh");
//	return 0;
//}
//
//
//
/////////////////                  = 赋值  和  == 判断相等的易错点
//int main()
//{
//	int a = 0;
//	if (a = 2)
//		printf("hh");
//	return 0;
//}
///////////////                  看似什么也不输出，其实输出hh，因为 = 是赋值
//
//int main()
//{
//	int a = 0;
//	if (2==a)
//		printf("hh");
//	return 0;
//}
////////////////                  所以最好用以 2==a 的形式，这样就算==错写为=，也只是报错，不会出现bug






/////////////////                      switch case 语句
/////////////////                      如下，从switch(变量)进入选择结果，按照变量的值跳入对应的case，并向下执行
/////////////////                      switch\case后面一定是整形表达式，因为switch判断条件是等于，精度要求高
/////////////////                               字符型、布尔型、枚举型都可以转化成整形进行判断
/////////////////                      case:后面必须是常量表达式
/////////////////                      break用来跳出循环，否则程序从在你跳入的case一直向下执行，直到switch语句结束或者遇到下一个break
/////////////////                      default:(默认)，如果输入的变量不在case:的范围内，则执行default(默认)  （确实用法相当于else)
/////////////////                      switch 语句中可以嵌套 if 或 switch 语句
//int main()
//{
//	int day;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1:
//		printf("星期1\n");
//		break;
//	case 2:
//		printf("星期2\n");
//		break;
//	case 3:
//		printf("星期3\n");
//		break;
//	case 4:
//		printf("星期4\n");
//		break;
//	case 5:
//		printf("星期5\n");
//		break;
//	case 6:
//		printf("星期6\n");
//		break;
//	case 7:
//		printf("星期7\n");
//		break;
//  default:
//      printf("输入错误");
//	}
//	return 0;
//}



/////////////////                         case后面不一定都加break
/////////////////                     此处若加break,则会从中间跳出，执行不到printf，所以这种情况不加break
//int main()
//{
//	int day;
//	scanf("%d", & day);
//	switch (day)
//	{
//	case 1:
//	case 2:
//	case 3:
//	case 4:
//	case 5:
//		printf("工作日\n");
//		break;
//	case 6:
//	case 7:
//		printf("休息日\n");
//		break;
//	default:
//		printf("输入错误\n");
//	}
//	return 0;
//}




////////////////                                    while语句
////////////////              continue:终止本次循环continue后面的代码，并跳回循环代码块，回到开头的判断部分
////////////////              break:直接跳出循环

//int main()
//{
//	int i = 0;
//	while (i < 10)
//	{
//		i++;
//		if (5 == i)
//			continue; /*break;*/
//		printf("%d\n", i);
//	}
//
//	return 0;
//}



////////////////                    for循环：for(表达式1; 表达式2;表达式3)
////////////////                            作用: 初始化;  判断  ;  调整
////////执行顺序：表达式1(初始化)->表达式2(判断)->执行循环体内语句->表达式3(调整)->2判断->循环体内语句执行->3调整->.......
// ////////////                     for 循环中也可出现 break 和 continue
//int main()
//{
//	int i;
//	for (i = 1; i<=10;i++)
//	{
//		printf("%d\n", i);
//	}
//	return 0;
//}


////////////////              对比下面两段代码
//////         二者区别在于 i++(调整) 的位置不同，for语句的调整在循环代码块外部(顶端),while语句的调整在代码块内部
//////         所以读取continue跳到循环语句开端处后，for语句执行调整 会继续运行 ，但while 语句不会调整变量的数组 进入死循环
// 
// 
//int main()
//{
//	int i;
//	for (i = 1; i <= 10; i++)
//	{
//		if (5 == i)
//			continue;
//		printf("%d ", i);
//	}
//	return 0;
//}


//int main()
//{
//	int i=1;
//	while (i <= 10)
//	{
//		if (5 == i)
//			continue;
//		printf("%d ", i);
//		i++;
//	}
//	return 0;
//}