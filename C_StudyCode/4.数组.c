//#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>
 
 
////数组的创建
//// type_t  arr_name  [const_n]
//// type_t   是指数组的元素类型
//// const_n  是一个"常量"表达式，用来指定数组大小



////////////                        一维数组
// 
//#include<string.h>
//int main()
//{
//	int arr[10] = { 1,2,3,4,5,98 };//不完全初始化(数组元素个数不到十个)，剩下元素默认初始化为0
// 
//	char arr2[10] = { 'a',98,'c' };//98会打印出b，因为要char类型下要对应转化为ASCII表的字母
//	printf("%s", arr2);
// 
//	char arr3[10] = "abc";//元素个数不够自动补0
// 
//	char arr4[] = "abcdef";//[]内容可省略, " "自动包括\0在内,元素个数为7
// 
//	printf("%d\n", sizeof(arr4));//计算arr所占空间大小，包括'\0'
// 
//	printf("%d\n", strlen(arr4));//求字符串长度，即'\0'之前的字符个数
// 
//	return 0;
//}





//sizeof 和 strilen 没有什么关联
//sizeof （只关注所占空间大小，与\0无关，\0也占空间）计算变量、数组、类型的大小-单位是字节 - 操作符
//strlen （长度指的是\0之前的字符个数）是求字符串长度的 - 只能针对字符串长度 - 库函数 -使用得引头文件

//#include<string.h>
//int main()
//{
//	char arr1[] = {'a','b','c'};
//	char arr2[] = "abc";
//	printf("%d\n", sizeof(arr1));//3
//	printf("%d\n", strlen(arr1));//随机值
//	printf("%d\n", sizeof(arr2));//4
//	printf("%d\n", strlen(arr2));//3
//	return 0;
//}






////////                        下标访问操作符：[]

//int main()
//{
//	char arr[] = "abcdef";
//	int i = 0;
//	for (i = 0; i < (int)strlen(arr) ; i++)// (int)是将字符串长度转换为整形，不然strlen输出的是无符号数，会警报
//	{
//		printf("%c ", arr[i]);
//	}
//	return 0;
//}


//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}






//////////                  数组中在内存中是连续存放的

//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10 };
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	for (i = 0; i < sz; i++)
//	{
//		printf("&arr[%d]=%p\n", i, &arr[i]);//%p:打印地址
//	}
//	return 0;
//}
//////& arr[0] = 00000057B7F6FA78
//////& arr[1] = 00000057B7F6FA7C
//////& arr[2] = 00000057B7F6FA80
//////.......
////结果可以发现每个元素相隔4个字节（每个整形占4字节），所以一维数组在内存中是连续存放的








////////////////         二维数组


//int main()
//{
//	
//		int arr [3][4];//第一个[]是横行，第二个[]是竖列
//
//		int arr1 [3][4] = { 1,2,3,4,5,6 };//每行满了自动换行，不完全初始化则剩下的自动补0
//
//		//     0123列 →            行：从0开始往下计
//        //                          列：从0开始往右计
//		// 0行   1 2 3 4        
//		// 1↓   5 6 0 0
//		// 2     0 0 0 0
//
//		int arr2 [3][4] = { {1,2,3},{4,5},{6} };//可以用{}框定每行放多少元素，行不满自动补0
//
//		//    列 →          
//		// 行  1 2 3 0       
//		// ↓  4 5 0 0
//		//     6 0 0 0
//
//		int arr3[][5]={1,2,3,4,5,6,7};//行可省略，列不可省略
//		return 0;
//	
//}




////////////                       访问二维数组(打印每个元素的值)

//int main()
//{
//	int arr[3][4] = { {1,2,3},{4,5},{6} };
//	int i;
//	for (i = 0; i < 3; i++)
//	{
//		int j;
//		for (j = 0; j < 4; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}






///////////////                   二维数组在内存中的存储
//int main()
//{
//	int arr[3][4] = { {1,2,3},{4,5},{6} };
//	int i;
//	for (i = 0; i < 3; i++)
//	{
//		int j;
//		for (j = 0; j < 4; j++)
//		{
//			printf("&arr[%d][%d]=%p  ", i, j, &arr[i][j]);
//		}
//		printf("\n");
//	}
//	return 0;
//}
//
//& arr[0][0] = 0000006ACC2FF938   & arr[0][1] = 0000006ACC2FF93C   & arr[0][2] = 0000006ACC2FF940   & arr[0][3] = 0000006ACC2FF944
//& arr[1][0] = 0000006ACC2FF948   & arr[1][1] = 0000006ACC2FF94C   & arr[1][2] = 0000006ACC2FF950   & arr[1][3] = 0000006ACC2FF954
//& arr[2][0] = 0000006ACC2FF958   & arr[2][1] = 0000006ACC2FF95C   & arr[2][2] = 0000006ACC2FF960   & arr[2][3] = 0000006ACC2FF964
//
//可以看出，每个元素相隔4个字节，所以二维数组在内存中也是连续存放的
//拆分思想，可以分别把arr[0] arr[1] arr[2]作为一个一维数组的数组名（把二维数组想象成由几个一维数组拼成的一维数组）









////////////                              冒泡函数排序（数组倒叙变正序）
// 
//void swap(int* pa,int* pb)//把两个元素交换的函数
//{
//	int z = *pa;
//	*pa = *pb;
//	*pb = z;
//}
//
//void f(int arr[],int sz)//通过冒泡排序把乱序数组变正序的函数
//{
//	int i;
//	int j;
//	for (i = 0; i < sz-1; i++)//总共要走的趟数
//	{
//		int a = 1;
//		for(j=0;j<sz-i-1;j++)//每一趟冒泡排序的内容
//			//这样写，可以保证（1~10）的乱序中，第一趟过后10在最后，第二趟过后9,10在最后......
//		if (arr[j] > arr[j + 1])
//		{
//			swap(&arr[j], &arr[j + 1]);
//			a = 0;
//		}
//		if (1 == a)//设a的作用是提高代码效率，假如某趟循环过后数组已经排成顺序，那么将不进入if内部，a的值是1不变，直接跳出大循环，不用之后一趟趟的判断，效率提升
//		{
//			break;
//		}
//	}
//}
//
//int main()
//{
//	int i = 0;
//	int arr[] = { 4,2,8,7,5,1,10,9,3,6 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	f(arr,sz);
//	for(i=0;i<sz;i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}
////结果为：1,2,3,4,5,6,7,8,9,10








////////选择排序
////////1 > 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
////////2 > 再从剩余未排序元素中继续寻找最小（大）元素，然后放到未排序序列的起始位置。
////////3 > 重复第二步，直到所有元素均排序完毕。
//
//void swap(int* pa,int* pb)//把两个元素交换的函数
//{
//	int z = *pa;
//	*pa = *pb;
//	*pb = z;
//}
//
//int main()
//{
//	int arr[10] = {  4,2,8,7,5,1,10,9,3,6  };//这里排完序变成由小到大从小到大
//	int i, j;
//	for (i = 0; i < 9; i++)//排序排9趟 ,第一趟把第一个放上最小的，第二趟把第二个放上次小的......
//	{
//		int t=i;
//		for (j = i + 1; j < 10; j++)//找出最小元素的下标放到t中，最后和arr[i]互换
//		{
//			if (arr[j] < arr[t])//找到每次中最小的元素
//			{
//				t = j;
//			}
//		}
//		swap(&arr[i],&arr[t]);
//	}
//
//	//打印
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//
//	return 0;
//}







/////////////////                 数组名是数组首元素地址（两个特例）
// //基本所有arr:首元素地址（为了节省内存空间）
// //sizeof(arr):整个数组
// //&arr:整个数组
// 
// 
//int main()
//{
//	int arr[] = { 1,2,3,4,5,6,7,8,9 };
//
//	//printf("%p\n", arr);//--------------地址相同
//	//printf("%p\n\n", &arr[0]);
//
//	//printf("%d\n", arr[0]);
//	//printf("%d\n\n\n", *arr);//-------------解引用后值相同
//
//
//
//	//特例
//	//1.sizeof(数组名)--数组名表示整个数组，可以用来计算整个数组的大小--单位字节
//	//2.&数组名--这里数组名代表整个数组，&数组名，取出的是整个数组的地址
//
//	//e.g.&数组名，代表整个地址，虽然值看上去相同，但是代表的意义不一样
//	// 
//	//首元素地址
//	printf("%p\n", arr);       //000000602BEFFBF8
//	printf("%p\n", arr+1);     //000000602BEFFBFC
//	//首元素地址
//	printf("%p\n", &arr[0]);   //000000602BEFFBF8
//	printf("%p\n", &arr[0]+1); //000000602BEFFBFC
//	//数组的地址
//	printf("%p\n", &arr);      //000000602BEFFBF8
//	printf("%p\n", &arr+1);    //000000602BEFFC1C
//
//	//打印结果可看出，arr和arr[0]与下一位差4字节
//	//&arr与下一位相差36字节（数组一共9个元素）
//
//	return 0;
//}







////////////////                                 数组运用时的格式
//
//#define hang 3
//#define lie 3
//
////一维数组传参
//void f0(int x[], int sz)//传参时，形参必须是随意数组名+[]，若是不加[]会被识别为整形
//{
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", x[i]);
//	}
//}
//
////二维数组传参
//void f(int x[][lie], int m, int n)
////传参时，形参必须是随意数组名+[][lie]，若是不加[][lie]会被识别为整形；
////第二个[]里必须填东西(规定)，且与原数组第二个[]内数字保持一致，不然出bug
//{
//	int i = 0; int j = 0;
//	for (i = 0; i < m; i++)
//	{
//		for (j = 0; j < n; j++)
//		{
//			printf("%d ", x[i][j]);
//		}
//		printf("\n");
//	}
//}
//
//int main()
//{
//	//创建数组时要明确表示出一个数组才可以
//	//一维数组，要么arr[]里填写数字,数组元素会为初始化，之后还要进行初始化
//	//          要么{}里规定元素，[]里会默认为元素个数
//	//二维数组，[][3]第二给括号（列）中必须填写数字
//	//          要么[][3]第一个元素里规定数字,数组元素会为初始化，之后还要进行初始化
//	//          要么[][3]{}里规定元素，[]里会根据元素个数，默认行数
//
//	int i = 0;
//
//	int arr[] = { 1,2,3,4,5,6,7 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//或
//	int arr1[7];//未初始化，不会自动补0，但格式不报错
//
//	int arr3[][3] = { 0 };
//	//或
//	int arr4[1][3];//未初始化，但格式不报错
//
//	
//
//
//	//传参时的格式要求
//	f0(arr, sz);//传参时，实参只写数组名,要是带[]会误认为某项元素
//
//	printf("\n");
//
//	int arr5[hang][lie] = { {1,2},{3,4,5},{6,7} };
//	f(arr5, hang, lie);//传参时，实参只写数组名
//}









////////////////scanf 与 gets 输入字符串
//
//
/////////////////scanf输入字符串
////scanf("%s",&arr) 或者 scanf("%s",arr) 相同
//// 1.留'\0'的位置
//// 若向 char arr[10]中用scanf输入字符串，只能输入9个字符，给'\0'留一个位置
//// 2.空格问题
//// 例如：scanf输入字符串时，总是在字符处停止扫描，如输入‘I am a student’，输出只为‘I’
//// 原因：scanf输入字符串的时候不会接收Space空格，回车Enter，Tab键，则认为输入结束。scanf函数直接从输入缓冲区中取数据，而并非从键盘(也就是终端)缓冲区读取。
////
//// 解决方法
//// 方法一：输入多个字符串，中间空格隔开
//// 方法二：gets()替代scanf()；
//
//
// 
// 
// 
// 
////////////////gets输入字符串
////gets(arr) 或者 gets(&arr) 相同 
//// 头文件：#include <stdio.h>
//// 该函数的声明：char* gets(char* str);
// 
//// 传参时直接传char*类型的地址，一般为字符串的首元素地址（数组名）








