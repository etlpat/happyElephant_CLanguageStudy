//#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>
//#include<stdlib.h>
//#include<string.h>









///////Debug和Release的介绍
////（二者在最上面的x64左边处切换）
////Debug通常称为调试版本：它包含调试信息[可用F10调试]，并且不做任何优化，便于程序员调试程序
////Release称为发布版本：它往往进行了各种优化，使得程序在代码大小和运算速度上都是最优的，以便用户更好的使用






////////////////最常用的几个快捷键


//////F5 启动调试，使程序直接运行到断点处（经过断点的顺序是程序执行的顺序）

//////F9 创建和取消断点，可在程序的任何和位置设置断点。
//////   这样就可以使程序在想要的位置随意停止执行，继而一步步执行下去；在循环中，可以右击间断点，给其加上条件，这样会使间断点在你想停止的循环次数中停止

//////F10 逐过程，通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句

//////F11 逐语句，就是每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑进入函数内部（这是最常用的）

//////Shift F11 可以用在执行调试的过程来跳出函数









//////////////  调试 - 窗口

///////// 自动窗口：自动监视你正在调试的步骤附近的变量，但是缺点是离你所在步骤较远的变量不会被监视到
///////// 局部变量： 和自动窗口差不多，不过专门监视离你所在步骤较近的局部变量
///////// 监视：手动输入变量来监视，用的最多
///////// 内存：手动输入来观察变量的内存（地址和内容），用的最多
///////// 反汇编：看看每一句C语言对应的汇编语言
///////// 寄存器：观察寄存器相关的值
///////// 调用堆栈：像栈一样的形式，从下往上展示函数调用的逻辑（先进的后出，后进的先出）







////////下面例子用来做实验
//int main()
//{
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d", i);
//	}
//	printf("\n");
//	for (i = 0; i < 10; i++)
//	{
//		printf("%d", 10 - i);
//	}
//
//	return 0;
//}








//////// 函数-窗口-调用堆栈的使用场景
//void test3()
//{
//	printf("kfc");
//}
//void test2()
//{
//	test3();
//}
//void test1()
//{
//	test2();
//}
//int main()
//{
//	test1();
//	return 0;
//}













//////////////     循环初始化数组元素，数组越界访问时造成死循环
//////////////     死循环条件（i和arr创建位置不能颠倒，如下，Dubug版本中，i在arr前定义，内存（栈）中i地址高于arr，越界才能访问到i）  (地址0最低)
//////////////                                               Release版本中会优化，i的地址低（有点编译器Debug版本也会优化）
//int main()
//{
//	int i = 0;
//	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
//	for (i = 0; i <= 12; i++)
//	{
//		printf("%-3d hehe\n", i);
//		arr[i] = 0;
//	}
//	return 0;
//}
//////在本编译器中报错，但是在版本比较低的编译器中会循环打印hehe,i的值从0~12循环，不同编译环境可以不一定是12，因为内存布局不同
// 
// 
/////// 栈区：从下到上 是 从低地址到高地址
// 
////1.栈区的默认使用：
////// 先使用高地址的空间，再使用低地址的空间
////2.数组再内存中连续存放
////// 数组随着下标的增长，数组元素地址由低到高
////// 数组越界访问时，继续访问相邻的高地址
// 
// 这里，arr[12]是 i 的地址，和编译器内存的布局有关，但是每次越界访问到arr[12]时，i的值就会被赋值为0，从0开始重新死循环


















////【assert(条件)】--【断言】-- 对应头文件#include<assert.h>
////assert:坚称，断言；维护，坚持；坚持自己的主张
////如果断言条件为真，什么都不会发生；如果断言条件为假，则报错，并提示错误具体位置












//////【const】修饰的常变量与指针
//int main()
//{
//	const int num = 4;
//	printf("%d\n",num);
//	num = 8;
//	printf(" % d\n",num);
//	return 0;
//}
//////结果会报错
//////因为const指的是常属性
//////这里int num前加const，num就是const修饰的常变量。前面num赋值是4，后面就不能在赋值8了
//////(本质是变量，但有常属性，在要使用常量的地方不能用)


///////但是通过地址的方式还是可以改变const修饰常量的值
//int main()
//{
//	const int num = 10;
//	int* p = &num;
//	*p = 20;
//	printf("%d", num);
//	return 0;
//}


////////所以在int* 左面也加上const，就可以防止用*p（解引用指针）的方式来更改数据
//int main()
//{
//	const int num = 10;
//	int num2 = 100;
//	const int* p = &num;
//	*p = 20;
//	//p = &num2;
//	printf("%d", num);
//	return 0;
//}
//////////       const 放在指针变量*左边时，修饰的是*p，这样就不能通过p改变*p(num)的值,但是p可以被赋值为其他地址
//////////       const 放在指针变量*右边时，修饰的是指针变量p本身，p不能被改为别的地址，但是*p可以改变
//int main()
//{
//	const int num = 10;
//  int num2 = 100;
//  int* const p = &num;
//	p = &num2;
//	printf("%d", num);
//	return 0;
//}











//void my_strcpy1(char* arr1, char* arr2)//版本1 ， 6/10分
//{
//	while (*arr1 != '\0')
//	{
//		*arr1 = *arr2;
//		arr1++;
//		arr2++;
//	}
//}
//
//
//void my_strcpy2(char* arr1, char* arr2) //版本2 ， 7/10分
//{
//	while (*arr1++ = *arr2++)//利用'\0'ASCII码值为0来当判断条件
//	{;}                      //++与*优先级相同，但是++先运算后自增
//
//}
//
//
//#include<assert.h>
//void my_strcpy3(char* arr1, char* arr2) //版本3 ， 8/10分
//{          
//	assert(arr1 != NULL);//【断言assert】-- 对应头文件#include<assert.h>
//	assert(arr2 != NULL);//      assert ---坚称，断言；维护，坚持；坚持自己的主张
//	////  如果断言条件为真，什么都不会发生；如果断言条件为假，则报错，并提示错误具体位置
//
//	while (*arr1++ = *arr2++){;}//这里要是传递了空指针过来，会导致程序崩溃，所以要断言没有传递空指针，规避这种逻辑错误                   
//}
//
//
//#include<assert.h>
//char* my_strcpy4(char* arr1,const char* arr2) //版本4 ， 10/10分
//{                       //加const修饰原字符串，防止其由于失误操作被覆盖
//	char* start = arr1;//保留目的地字符串的起始地址
//	assert(arr1 != NULL);//断言，若是出入空字符串则提出警告
//	assert(arr2 != NULL);//断言
//	while (*arr1++ = *arr2++) { ; }//最简单的循环写法
//	return start;//返回目的地字符串起始地址，方便以后函数调用
//}
//
//
//int main()
//{
//	char arr1[] = "#####asdfgh#####";
//	char arr2[] = "hello";
//	//strcpy(arr1, arr2);//前面是目的地，后面是来源
//	my_strcpy4(arr1, NULL);//把原字符串拷贝到目的地字符串的函数
//	printf("%s\n", arr1);
//	return 0;
//}















/////////////////// 参考代码逐步完善的过程，模拟实现 my_strlen()
//#include<assert.h>
//
//int my_strlen(const char* arr)//实现求字符串长度的函数
//{         ////const放在char*前面，保证输入是字符串内容不被修改
//	assert(arr != NULL);//断言,保证指针的有效型
//	int i = 0;
//	//判断每次*arr是否为'\0'，不是则进入循环i+1；是则条件不成立退出循环
//	while (*arr++)
//	{
//		i++;
//	}
//	return i;
//}
//
//
//int main()
//{
//	char arr[] = "abcdef";
//	int len = my_strlen(arr);
//	printf("%d", len);
//	return 0;
//}












//////常见错误类型
//////编译型错误（语法错误）
//////直接看错误提示信息（双击），解决问题，简单
//////链接型错误
//////看错误信息，主要在代码中找到错误信息的标识符，然后定位问题所在，一般是标识符名不存在或者是拼写错误
//////运行时错误
//////没前两种错误，但是运行出来结果不符合。借助调试，逐步定位问题，最难搞