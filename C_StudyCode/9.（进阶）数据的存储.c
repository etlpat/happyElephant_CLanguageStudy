//#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>








//////////C语言类型

////1.内置类型
////char  short  int  long  float  double  unsigned...

////2.自定义类型
////数组  结构体  共用体

//类型的意义
//1.使用这个类型开辟内存空间的大小(大小决定了使用范围)
//2.如何看待这块内存空间的视角(这块空间内容应被看待为什么类型)


//int main()
//{
//	printf("%d\n", sizeof(int));//4
//	printf("%d\n", sizeof(float));//4
//	int a = 10;    //0a 00 00 00 
//	int b = 10;    //0a 00 00 00 (调试-窗口-内存)
//	float c = 10.0;//00 00 20 41
//	//可以看出不同数据类型，即使值相同，但在内存中存储数据也是不同的
//	return 0;
//}





////整形家族
//char
//    unsigned char    0--255
//    signed char      -128--127
//short
//     unsigned short [int]
//     signed short [int]
//int  
//     unsigned int
//     signed int
//long 
//     unsigned long [int]
//     signed long [int]


////浮点型家族
//float
//double


////自定义类型
//数组类型     int arr[10];   去掉数组名就是数组类型,数组类型是 int[10]
//结构体类型   struct
//枚举类型     enum
//联合类型     union


//指针类型(大小一致，都是用来存地址的)
//int *pi  
//char *pc
//float *pf
//void* pv


//空类型
//void 表示空类型(无类型)
//常应用于函数的返回值，函数的参数，指针类型




//int main()//整形提升是对应你变量的类型来提升，char就提升为32位有符号数，unsigned char就提升位32位无符号数
//          //整型提升与打印时的%d或是%u无关
//{
// 
//	//-1是整形（虽说-1要放进char里，但是-1本身还是整形-1）
//	//10000000 00000000 00000000 00000001 -- 原
//	//11111111 11111111 11111111 11111111 -- 补
//
//	char a = -1;
//	//存到 char a 中时发生截断
//	//11111111 - 补
//	 
//	//下面要求打印整数，a是char，按照char的规则整型提升
//	//11111111 11111111 11111111 11111111 -- 补 = -1
//	printf("%d\n", a);
//	//以 %d 形式打印(%d打印32位有符号整形)
//	
//
//	unsigned char b = -1;
//	//存到 unsigned char b中时发生截断
//	//11111111 - 补
// 
//    //下面要求打印整数，b的类型是unsigned char，所以按照unsigned的方式整形提升
//    //00000000 00000000 00000000 11111111 -- 补 = 255
//	printf("%d\n", b);
//	//以 %d 形式打印
//	return 0;
//}



//int main()
//{
//	//-128原本是
//	//10000000 00000000 00000000 10000000 -- 原码
//	//11111111 11111111 11111111 10000000 -- 补码
//	char a = -128;
//	//10000000 -- 截断存入a中
//	
//	//因为下面要打印整数，a类型是char，所以按char类型整形提升
//	//11111111 11111111 11111111 10000000
//	printf("%u\n", a);//%u打印32位无符号整形
//	//因为是无符号数，所以按无符号数的规则打印
//	return 0;
//}






















////原码、反码、补码
////计算机中的[整形有符号数]有三种表示方法，即原码、反码、补码  [整形无符号数原=反=补]
////三种表示方法均有[符号位]和[数值位]两部分，符号位都是有0正1负

////有符号整数[原=反=补]
////有符号负数如下
//////原码：直接按照正负数的形式翻译成二进制
//////反码：原码符号位不变，其它位按位取反
//////补码：反码+1

////对于整数来说：数据以补码的形式存放在内存中
////原因：补码可以将符号位和数值域统一处理；同时加法减法也可以统一处理(cpu只有加法器)；
////////  补码和原码进行转换，运算过程相同，不需要额外的硬件电路



//int main()
//{
//	int a = 20;
//	//00000000 00000000 00000000 00010100 -- 原码 = 反码 = 补码
// 	//0x 00 00 00 14 (内存展示的数(补码))
//	int b = -10;
//	//10000000 00000000 00000000 00001010 -- 原码
//	//11111111 11111111 11111111 11110101 -- 反码
//	//11111111 11111111 11111111 11110110 -- 补码
//	//0x ff ff ff f6 (内存展示的数(补码))
//	return 0;
//}





///////(cpu只有加法器)
//有加法就可以加减乘除
//减法  5-3 -> 5+(-3)
//乘法  5*3 -> 5*2+5 = 5<<1+5

 
//int main()//因为cpu只要加法器
//{
//	1 - 1;
//	//相当于 1 + (-1);
//	     //所以用补码进行储存才能直接运算
////       00000000 00000000 00000000 00000001
////   +   11111111 11111111 11111111 11111111
////   =  100000000 00000000 00000000 00000000
////截断   00000000 00000000 00000000 00000000
//	return 0;
//}


//////逻辑实现加法
//int add(int a,int b)
//{
//	return b ? add(a ^ b, (a & b) << 1) : a;
// //这里返回b的意义是:当b为真(有位可进),进行递归;当b为假(进位为0，无位可进),返回a(最终的本位)
//}

//上面函数 add(a, b) = add(a ^ b, ((a & b) << 1))  相当于  add[a=本次结果 , b=进位结果]
// 
//每一次运算 a+b就是(a^b+((a&b)<<1))      [本位 同为0 异为1 ; 进位 同1为1 同0为0 相异为0  (这里0 1表示本位的0 1)]
//                   本位 + 进位
//若执行完一次上述运算以后，若(本位+进位 != 本位^进位)，也就是相加时仍有位可进，那么就需要进行重复上面过程(递归)
//最后当无位可进（已经到最高位）递归结束。
//就如（1010 & 0101 = 0 所以 1010 + 0101时，b为假，这时就不需要进位了）







/////////内存 - 补码(按一个字节来计算)
////////从0开始循环加1
//00000000 -- 0
//00000001 -- 1
//00000010 -- 2
//00000011 -- 3
//......
//01111111 -- 127
//10000000 -->（-128）规定此二进制不会被真实计算，只要识别到，直接翻译为-128
//10000001 -- 11111111(原) = -127
//......
//11111101 -- 10000011(原) = -3
//11111110 -- 10000010(原) = -2
//11111111 -- 10000001(原) = -1
//00000000 -- 0 -- 截断，开始循环
//00000001 -- 1
//00000010 -- 2


//-128若是用32字节来看
//11111111 11111111 11111111 10000000 - 补
//10000000 00000000 00000000 10000000 - 原
//类比到8bit中，10000000直接翻译为-128

//所以有符号的char范围 -128 --> 127 
//反码从00000000 -> 11111111 【0 1 2 ... 127 -128 -127 -126 ... -2 -1 ；0(循环)】
//char中，-128 - 1 = -127 (截断)









//////////////////////////////     几道习题

//////////  输出什么？
//int main()
//{
//	int a = 10;
//	//00000000 00000000 00000000 00001010
//	unsigned int b = -20;
//	//10000000 00000000 00000000 00010100
//	//11111111 11111111 11111111 11101100
//	printf("%d", a + b);      
//	//11111111 11111111 11111111 11110110
//	//10000000 00000000 00000000 00001010
//	return 0;
//}


////////输出什么？
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	//11111111 11111111 11111111 11111111
//	//+
//	//00000000 00000000 00000000 00001001
//	//00000000 00000000 00000000 00001000
//	//00000000 00000000 00000000 00000111
//    //...
//	//00000000 00000000 00000000 00000000
//	//11111111 11111111 11111111 11111111
//	//11111111 11111111 11111111 11111110
//	return 0;
//}


//////////  输出什么？
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));//'\0'之前的元素个数
//	return 0;
//}
////  -1:1111... 11111111//补
////...
////直到 1111...100000000 = 截断: 00000000 = '\0'
////     1111...011111111(反)
////-256:1000...100000000(原)


//////////  输出什么？
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("%d hello world\n",i);
//	}
//	return 0; 
//}
////00000000
////...
////11111111
////00000000
////...























///////////  大端和小端(描述数据以【字节为单位】在内存中的存储顺序)
///////////  全称（大端字节序存储模式，小端字节序存储模式）

//////(我们可以看见数据在不同环境的内存中，有时正着存，有时倒着存)
////大端(存储)模式：是指数据的 低位保存在内存的高地址中，高位保存在低地址中（正着存）
////小端(存储)模式：是指数据的 低位保存在内存的低地址中，高位保存在高地址中（倒着存）
////上面大端正着存,小端存倒着存都是【以字节为单位存储】，一字节一字节正/倒着存，表现为内存中[十六进制]中的[两个数为一组] 


//////存在大端小端的原因：计算机系统中以字节为单位，每个存储单元对应1字节=8个比特位。但C语言除了8bit的char,还有16bit的short、32bit的int。
//////且，对于位数大于8位的处理器，例如16位或32位，由于寄存器宽度大于一字节，那么必然存在如何安排多字节的问题。所以就有了大端与小端的存储模式




//int main()
//{
//	int a = 0x1a2b3c4d; // 在内存中为 4d 3c 2b 1a，低质低位，所以当前编译器是小端存储模式
//	return 0;
//}
/////所以当前VS编译器下是小端存储模式
/////上面a的值 1a 2b 3c 4d , 位数左端(1a)最高
/////a在内存中 4d 3c 2d 1a , 地址从左到右是由低到高
///// a内存中低地址对应低位数，高地址对应高位数，即地址低位，高址高位，小端储存（倒着存） 









/////////////    设计一个程序判断当前机器字节序是大端还是小端
/////指针的类型决定了指针解引用能够访问几个字节，所以想取前两位低地址字节就用char* p即可

//int main()
//{
//	int a = 1;  // 00 00 00 01 -> 01 00 00 00(小端) 00 00 00 01(大端)
//	char* p = (char*)&a;//不强制类型转化会警报类型不兼容
//	if (1 == *p)
//	{
//		printf("小端\n");
//	}
//	else if (0 == *(p + 3))
//	{
//		printf("大端\n");
//	}
//	return 0;
//}



///////////函数简化法
//
//int f(void)//若是小端，返回1 ；若是大端，返回0
//{
//	int i = 1;
//	return  *(char*)&i;//对char*解引用，返回的还是一个字节
//	//返回(char*)&i 若是 1，小端  ； 若是0，大端
//}
//
//int main()
//{
//	int a = f();
//	if (a == 1)
//	{
//		printf("小端");
//	}
//	else
//	{
//		printf("大端");
//	}
//	return 0;
//}



























////////////////////////////                  浮点数在内存中的存储
 

/////////////先尝试运行以下例子
//int main()
//{
//	int a = 9;
//	float *pF = (float*)&a;
//	printf("%d\n", a);          //9
//	printf("%f\n", *pF);        //0.000000
//	printf("%f\n", (float)a);   //9.000000
//	*pF = 9.0;
//	printf("%d\n", a);          //1091567616
//	printf("%f\n", *pF);        //9.000000
//	printf("%d", (int)*pF);     //9
//	return 0;
//}                               //可看出浮点数与整形在内存中存储形式不一样








//////////////////       【浮点数储存的详细解释】
///////根据国际标准IEEE(电气电子工程师学会)754，任意一个二进制浮点数“V”可以表示成下面的形式
////////////  【 V = (-1)^S * M * 2^E 】
// 
////////  【 (-1)^S 】表示符号位：S=0时，V为正数 ；S=1时，V为负数 （还是0正，1负）
////////  【 M 】表示有效数字，大于等于1，小于2（M是 1.xxxxx 的形式）
////////  【 2^E 】表示指数位（*2^E 相当于 <<E）


////e.g.
////十进制的5.0，写成二进制就是101.0，相当于 (-1)^0 * 1.01 * 2^2 
////那么，按照上面V的格式，可得出 S=0，M=1.01，E=2
//// (-1)^0 * 1.01 * 2^2 （假设先不考虑M和E的特殊规定是这样的结果）
//// (-1)^S *  M   * 2^E




////////上面例子可以看出，只要有 S E M 就可以表示出浮点数

//////// IEEE 754规定：对于32位浮点数(float)，最高位的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。
////////     |S|---E----|------------M------------|（单精度浮点数存储模型）
////////    1bit   8bit              23bit

//////// 对于64位浮点数(double)，最高的一位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。
////////     |S|-----E-----|-------------------------M--------------------------|（双精度浮点数存储模型）
////////    1bit     11bit                          52bit


//////// IEEE 754对有效数字M和指数E，有一些【特殊规定】。

////// 【M】：由于 1<=M<=2,也就是说，M可以写成1.xxxxx 的形式，其中xxxxx表示小数部分
////// 计算机保存M时，默认这个数的第一位总是1，因此可以省去，只保留后面的xxxxx部分，最后读取的时候，再把第一位的1加上去。
////// 这样做的意义是：节省一位有效数字，可以提高一位精度


////// 【E】：首先，E为一个无符号整数，取值范围 (8位:0-255);(11位:0-2047)，但是，科学计数法中E可能出现负数
////// 所以IEEE 754规定，无论正负，E存入内存必须加上一个《中间数》,(8位E,中间数127);(11位E,中间数1023)
////// 存的时候加上《中间数》，就可将负数转化为正数，机器进行计算时再自动减掉减掉









//(十进制)0.5 -> (二进制)0.1 = (-1)^0 * 1.0 * 2^-1
// 一个二进制数 011101.110100
// 其整数部分每一位权重是（2^0  ,2^1  ,2^2  ,...）
// 其负数部分每一位权重是（2^-1 ,2^-2 ,2^-3 ,...）
//所以二进制0.1为2^-1 = 0.5




////////////     浮点数9.5在内存中是多少？
//int main()
//{
//	float a = 9.5;
//	//9.5 = 1001.1 = (-1)^0 * 1.0011 * 2^3
//	//0 , 3+127 , 0011
//	//0 10000010 0011...
//	//01000001 00011000 00000000 00000000
//	//0X 41 18 00 00
//	//小端存为 00 00 18 41
//	return 0;
//}






//////////  然后，指数E从内存中取出还可以再分成三种情况

//////【E不全为0或不全为1】
////这时，指数E的储存值减去127（或1023）就得到真实值，再将M前加上第一位的1.

//////【E全为0】
////这时做特殊处理，指数储存的值规定为 1-127（或 1-1023）有效数字前面不再加第一位的1，而是还原为0.xxxxx的小数
////这么做是为了表示正负0，已经接近于0的小数

//////【E全为1】
////这时做特殊处理，不管M是否全为0，都表示正负无穷大，正负取决于符号位S






//int main()
//{
//	int a = 9;
//	float *pF = (float*)&a;
//	printf("%d\n", a);          //00000000 00000000 00000000 00001001//输出9
//	printf("%f\n", *pF);        //S=0 E=00000000 M=00000000000000000001001 ,E全为0，无限小//输出0.000000
//	                                       //（其实是(-1)^0 * 0.00000000000000000001001 * 2^-126）
//	*pF = 9.0;
//	printf("%f\n", *pF);        //S=0 E=3+127=10000010 M=00100000000000000000000//输出9.000000
//	printf("%d\n", a);          //01000001000100000000000000000000//输出1,091,567,616
//	return 0;
//}                   