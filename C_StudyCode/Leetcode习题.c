#define _CRT_SECURE_NO_WARNINGS 1



//////////////////////////////////////////////////////////////////////////////////////////////////////
////1. 两数之和
////给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
////你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
////你可以按任意顺序返回答案。
////
////示例 1：
////输入：nums = [2, 7, 11, 15], target = 9
////输出：[0, 1]
////解释：因为 nums[0] + nums[1] == 9 ，返回[0, 1] 。
// 
//#include<stdio.h>
//#define num 10
//
//int* pri(int arr[], int sz)
//{
//	int i;
//	for (i = 0; i < sz; i++)
//	{
//		scanf("%d", &arr[i]);
//	}
//	return arr;
//}
//
//void judge(int* arr, int x, int sz)
//{
//	int i, j, n=0;
//	for (i = 0; i < sz; i++)//i从0到sz-1递增
//	{
//		for (j = i+1; j < sz; j++)//j从i+1到sz-1递增，可以保证不和i重复
//		{
//			if (arr[i] + arr[j] == x)
//			{
//				printf("%2d+%-2d=%-2d，下标为%2d,%-2d\n", arr[i], arr[j], x, i, j);
//				n++;
//			}
//		}
//	}
//	if (n == 0)
//	{
//		printf("没有想要的结果\n");
//	}
//}
//
//int main()
//{
//	int arr[num] = { 0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	printf("输入数组元素\n");
//	pri(arr, sz);
//	printf("输入目标数字\n");
//	int target;
//	scanf("%d", &target);
//	judge(arr, target, sz);
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////











////////////////////////////////////////////////////////////////////////////////////////////////////////
//////44. 通配符匹配
//////给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。
//////'?' 可以匹配任何单个字符。'*' 可以匹配任意字符串（包括空字符串）。两个字符串完全匹配才算匹配成功。
//////说明 :
//////s 可能为空，且只包含从 a - z 的小写字母。
//////p 可能为空，且只包含从 a - z 的小写字母，以及字符  ? 和  * 。
////// 
//////示例 1 : 
//////输入:s = "aa",p = "a"
//////输出 : false
//////解释 : "a" 无法匹配 "aa" 整个字符串。
////// 
//////示例 2 :
//////输入:s = "aa",p = "*"
//////输出 : true
//////解释 : '*' 可以匹配任意字符串。
////// 
//////示例 3 :
//////输入:s = "cb",p = "?a"
//////输出 : false
//////解释 : '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
////// 
//////示例 4 :
//////输入:s = "adceb",p = "*a*b"
//////输出 : true
//////解释 : 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
////// 
//////示例 5 :
//////输入 :s = "acdcb",p = "a*c?b"
//////输出 : false
//
//
//
//////char *gets( char *buffer );  返回值：成功返回实参（首元素地址），失败返回NULL；形参：输入字符串的存储位置（首元素地址）
//////gets函数,输入一行字符组成一行字符串，该字符串由第一个换行符('\n')以外的所有字符组成。然后在返回行之前将换行符替换为空字符('\0')。
//////  '\n'==10  ， '\0'==0
//
//#include<stdio.h>
//#define MAX 20
//
//char* my_gets(char* arr)//输入字符串的函数
//{
//	int i;
//	for (i = 0;; i++)//这里每输入一次，i+1。若遇到'\n'则将其改为'\0'
//	{
//		*(arr + i) = getchar();
//		if (*(arr + i) == '\n')
//		{
//			break;
//		}
//	}
//	*(arr + i) = '\0';
//	return arr;
//}
//
//
//void judge(char* arr1, char* arr2)//根据题意给出的判断函数
//{
//	int i = 0, j = 0;
//	while (1)
//	{
//		if (arr1[i] == '\0' && arr2[j] == '\0')
//		{
//			printf("true");
//			break;
//		}
//		if (arr2[j] != '*' && arr2[j] != '?')
//		{
//			if (arr1[i] == arr2[j])
//			{
//				i++;
//				j++;
//			}
//			if (arr2[j] != '*' && arr2[j] != '?' && arr1[i] != arr2[j])
//			{
//				printf("false");
//				break;
//			}
//		}
//		if (arr2[j] == '*')//当arr2的元素*，arr2向后跳一位，arr1元素向后循环跳，直到等于[arr2的*的下一位]或['0']
//		{
//			j++;
//			do
//			{
//				i++;
//			} while ((arr1[i] != '0') && (arr1[i] != arr2[j]));
//		}
//		if (arr2[j] == '?')//若arr2元素为？，两数组均向后跳一元素
//		{
//			i++;
//			j++;
//		}
//	}
//}
//
//int main()
//{
//	char arr1[MAX] = { 0 };
//	char arr2[MAX] = { 0 };
//	my_gets(arr1);
//	my_gets(arr2);
//	judge(arr1, arr2);
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////













//////////////////////////////////////////////////////////////////////////////////////////////////////
////////76. 最小覆盖子串
////////给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
////////注意：
////////对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
////////如果 s 中存在这样的子串，我们保证它是唯一的答案。
////////
////////示例 1：
////////输入：s = "ADOBECODEBANC", t = "ABC"
////////输出："BANC"
////////
////////示例 2：
////////输入：s = "a", t = "a"
////////输出："a"
////////
////////示例 3:
////////输入: s = "a", t = "aa"
////////输出 : ""
////////解释 : t 中两个字符 'a' 均应包含在 s 的子串中，
////////因此没有符合条件的子字符串，返回空字符串。
//#include<stdio.h>
//#include<string.h>
//#define MAX 20
//
//void f(char arr1[], char arr2[], char arr3[])
//{
//	int a=-1, b=-1;
//	int len1 = strlen(arr1);
//	int len2 = strlen(arr2);
//	int i, j, a = 0;
//	for (i = 0; i < len2; i++)
//	{
//		for (j = 0; j < len1; j++)
//		{
//			if(arr2[i]==arr1[j])
//
//
//		}
//	}
//
//}
//
//
//int main()
//{
//	char arr1[MAX];
//	char arr2[MAX];
//	gets(arr1);
//	gets(arr2);
//	char arr3[MAX] = { 0 };
//	f(arr1, arr2, arr3);
//
//}
//
//
//









//////////////////////////////////////////////////////////////////////////////////////////////////////
////////350. 两个数组的交集 II
////////给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。
////////返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致
////////（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
////////
////////示例 1：
////////输入：nums1 = [1, 2, 2, 1], nums2 = [2, 2]
////////输出：[2, 2]
////////
////////示例 2:
////////输入：nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]
////////输出：[4, 9]
//////////
//////////提示：
//////////1 <= nums1.length, nums2.length <= 1000
//////////0 <= nums1[i], nums2[i] <= 1000
//
// 
//#include<stdio.h>
//
//int strsca(char arr[], int sz)//数组中输入元素函数
//{
//	int i,num=0;
//	for (i = 0; i < sz; i++)
//	{
//		arr[i] = getchar();
//		num++;
//		if (arr[i] == 10)//回车时，getchar()获得的值时'\n'，对应ASCII值为10
//		{
//			arr[i] = '\0';  
//			num--;
//			break;
//		}
//	}
//	return num;
//}
//
//
//void pri(char arr[], int sz)//打印函数
//{
//	int i;
//	for (i = 0; i < sz && arr[i] != '\0'; i++)
//	{
//		printf("%c ", arr[i]);
//	}
//}
//
//
//int initarr(int(*pstrsca)(char*,int),char arr[], int sz)//初始化数组函数
//{
//	printf("请输入数组：>");
//	int a = pstrsca(arr, sz);
//}
//
//
//void judge(char* arr1, char* arr2, char* arr3)//实现交集放入arr3的数组
//{
//	while ((*arr1) && (*arr2))
//	{
//		if (*arr1 == *arr2)
//		{
//			*arr3 = *arr1;
//			arr1++, arr2++, arr3++;
//		}
//		else if ((*arr1 >= *arr2) || *arr1 == '\0')
//		{
//			arr2++;
//		}
//		else if ((*arr2 >= *arr1) || *arr2 == '\0')
//		{
//			arr1++;
//		}
//	}
//	*arr3 = '\0';
//}
//
//
//void p(char arr[], int num)//数组排序函数
//{
//	int i, j;
//	for (i = 0; i < num-1; i++)//循环num-1次，每次目的是第一次把最大的放最后，第二次把次大的放倒数第二个位置...
//	{
//		for (j = 0; j < num - i - 1; j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				char tmp = arr[j];
//				arr[j] = arr[j+1];
//				arr[j+1] = tmp;
//			}
//		}
//	}
//}
//
//int main()
//{
//	char arr1[20] = { 0 };
//	char arr2[20] = { 0 };
//	char arr3[20] = { 0 };
//	int sz = sizeof(arr1) / sizeof(arr1[0]);
//	int num1 = initarr(strsca, arr1, sz);//初始化数组元素,返回元素个数
//	int num2 = initarr(strsca, arr2, sz);
//	p(arr1, num1);//排序函数
//	p(arr2, num2);
//	int max = num2;
//	if (num1 > num2)
//	{
//		max = num1;//max是最大数组的元素个数
//	}
//	judge(arr1, arr2, arr3);
//	pri(arr3,sz);
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////////////////////////////
////803. 打砖块
////有一个 m x n 的二元网格 grid ，其中 1 表示砖块，0 表示空白。砖块 稳定（不会掉落）的前提是：
////一块砖直接连接到网格的顶部，或者至少有一块相邻（4 个方向之一）砖块 稳定 不会掉落时
////给你一个数组 hits ，这是需要依次消除砖块的位置。每当消除 hits[i] = (rowi, coli) 位置上的砖块时，
////对应位置的砖块（若存在）会消失，然后其他的砖块可能因为这一消除操作而掉落 。一旦砖块掉落，它会 立即 从网格 grid 中消失（即，它不会落在其他稳定的砖块上）。
////返回一个数组 result ，其中 result[i] 表示第 i 次消除操作对应掉落的砖块数目。
////注意，消除可能指向是没有砖块的空白位置，如果发生这种情况，则没有砖块掉落。
////
////示例 1：
////输入：grid = [[1, 0, 0, 0], [1, 1, 1, 0]], hits = [[1, 0]]
////输出：[2]
////解释：网格开始为：
////[[1, 0, 0, 0]，
////[1, 1, 1, 0]]
////消除(1, 0) 处加粗的砖块，得到网格：
////[[1, 0, 0, 0]
////[0, 1, 1, 0]]
////两个加粗的砖不再稳定，因为它们不再与顶部相连，也不再与另一个稳定的砖相邻，因此它们将掉落。得到网格：
////[[1, 0, 0, 0],
////[0, 0, 0, 0]]
////因此，结果为[2] 。
//// 
////示例 2：
////输入：grid = [[1, 0, 0, 0], [1, 1, 0, 0]], hits = [[1, 1], [1, 0]]
////输出：[0, 0]
////解释：网格开始为：
////[[1, 0, 0, 0],
////[1, 1, 0, 0]]
////消除(1, 1) 处加粗的砖块，得到网格：
////[[1, 0, 0, 0],
////[1, 0, 0, 0]]
////剩下的砖都很稳定，所以不会掉落。网格保持不变：
////[[1, 0, 0, 0],
////[1, 0, 0, 0]]
////接下来消除(1, 0) 处加粗的砖块，得到网格：
////[[1, 0, 0, 0],
////[0, 0, 0, 0]]
////剩下的砖块仍然是稳定的，所以不会有砖块掉落。
////因此，结果为[0, 0] 。
//
//#include<stdio.h>
//#include<stdlib.h>
//#define hang 4
//#define lie 6
//
//void pri(int arr[hang][lie])//打印 #注意数组指针记得看*和[]的优先级问题
//{
//	int i=0, j=0,a=0,b=0;
//	for (a = 0; a <= lie; a++) {
//		printf("%d ", a);
//	}
//	printf("\n");
//	for (b = 0; b <= lie; b++) {
//		printf("--");
//	}
//	printf("\n");
//	for (i = 0; i < hang; i++)
//	{
//		printf("%d|", i + 1);
//		for (j = 0; j < lie; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//		printf("\n");
//	}
//}
//
//int input(int arr[hang][lie])//输入砖块坐标的函数
//{
//	printf("请输入砖块坐标 x y :>");
//	int x, y, r;
//	scanf("%d %d", &x, &y);
//	if (0 <= x - 1 && x - 1 < hang && 0 <= y - 1 && y - 1 < lie)
//	{
//		arr[x - 1][y - 1] = 1;
//	}
//	else
//	{
//		printf("输入非法坐标\n");
//	}
//	printf("停止添砖？(0停/任意键继续)");
//	scanf("%d", &r);
//	return r;
//}
//
//
////寻找相邻1砖块，把搜寻过的1砖块值变为2，用来防止重复搜索砖块
////并且用地址ph记录最高处的砖块是否为0的函数，是0，之后砖块脱落，是1，仍然连接接
//void down(int arr[hang][lie], int i, int j, int* ph)//(想要向周围4个方向寻找的值，行，列，值最小的行)
//{
//	if (arr[i][j] == 1) 
//	{
//		arr[i][j] = 2;
//		if (*ph > i) {//记录最高处位置（i最低）
//			*ph = i;
//		}
//		if (0 <= i && i < hang && 0 <= j && j < lie)//当在边框范围内
//		{
//			down(arr, i - 1, j, ph);
//			down(arr, i, j - 1, ph);
//			down(arr, i, j + 1, ph);
//			down(arr, i + 1, j, ph);
//		}
//	}
//}
//
//
//void init(int arr[hang][lie], int t)//把被标记过（即由1->2）的砖块改成1或0的函数
//{
//	int i, j;
//	for (i = 0; i < hang; i++)
//	{
//		for (j = 0; j < lie; j++)
//		{
//			if (arr[i][j] == 2)
//			{
//				arr[i][j] = t;
//			}
//		}
//	}
//}
//
//void judge(int arr[hang][lie], int h0, int i, int j)//判断最高处砖头是否为1，是则砖块保留，否则砖块脱落
//{
//	down(arr, i, j, &h0);
//	if (h0 != 0) {
//		init(arr, 0);
//	}
//	else {
//		init(arr, 1);
//	}
//}
//
//
//void play(int arr[hang][lie])//开始进行敲砖
//{
//	int r = 0;
//	do
//	{
//		int x, y;
//		printf("输入想要敲掉的砖块坐标");
//		scanf("%d %d", &x, &y);
//		int m = 1;
//		while (m)//直到输入的坐标合法才退出循环
//		{
//			if (0 <= x - 1 && x - 1 < hang && 0 <= y - 1 && y - 1 < lie)//判断坐标合法性
//			{
//				if (arr[x - 1][y - 1] = 1)
//				{
//					arr[x - 1][y - 1] = 0;
//					pri(arr);
//					m = 0;
//				}
//				else
//				{
//					printf("此位置并没有砖块\n");
//					continue;
//				}
//			}
//			else
//			{
//				printf("输入非法坐标,请重新输入\n");
//				continue;
//			}
//		}
//		int m1 = x - 1, n1 = y - 1;
//
//		judge(arr, m1 - 1, m1 - 1, n1);//上（下标）           //判断敲掉的砖头周围4个是否保留
//		judge(arr, m1, m1, n1 - 1);//左
//		judge(arr, m1 + 1, m1 + 1, n1);//下
//		judge(arr, m1, m1, n1 + 1);//右
//		system("cls");
//		pri(arr);
//		printf("停止敲砖？(0停/任意键继续)");
//		scanf("%d", &r);
//
//	} while (r);
//}
//
//
////1 3 1 2 3 1 3 3 1 3 2 1 3 1 1 3 4 1  4 3 1 4 2 0
////1 3 1 2 3 1 3 3 1 3 2 1 3 1 1 3 4 1  4 3 0
//int main()
//{
//	int r;
//	int arr[hang][lie] = { 0 };
//	pri(arr);
//	do
//	{
//		r = input(arr);
//		system("cls");
//		pri(arr);
//	} while (r);
//	play(arr);
//
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////










//////////////////////////////////////////////////////////////////////////////////////////////////////
//////922. 按奇偶排序数组 II
//////给定一个非负整数数组 nums，  nums 中一半整数是 奇数 ，一半整数是 偶数 。
//////对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。
//////你可以返回 任何满足上述条件的数组作为答案 。
//////
//////示例 1：
//////输入：nums = [4, 2, 5, 7]
//////输出：[4, 5, 2, 7]
//////解释：[4, 7, 2, 5]，[2, 5, 4, 7]，[2, 7, 4, 5] 也会被接受。
//////
//////示例 2：
//////输入：nums = [2, 3]
//////输出：[2, 3]
//////
//////进阶：可以不使用额外空间解决问题吗？
//#include<stdio.h>
//
//#define MAX 20
//
//void pri(int arr[],int sz)//打印函数
//{
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d", arr[i]);
//	}
//}
//
//void swap(int* a1, int* a2)//交换函数
//{
//	int tmp = *a1;
//	*a1 = *a2;
//	*a2 = tmp;
//}
//
//void f(int arr[], int sz)//实现题目要求的函数
//{
//	int ji=0, o=1;
//	for (ji = 0, o = 1; ji < sz && o < sz; ji += 2, o += 2)//默认奇数元素==偶数元素
//	{
//		for (ji = 0; ji < sz; ji += 2)//找到奇数下标的偶元素
//		{
//			if (arr[ji] % 2 == 0) {
//				break;
//			}
//		}
//		for (o = 1; o < sz; o+=2)//找到偶下标的奇函数
//		{
//			if (arr[o] % 2 == 1) {
//				break;
//			}
//		}
//		swap(&arr[ji], &arr[o]);
//	}
//}
//
//int main()
//{
//	int arr[] = { 1,3,5,7,9,2,4,6,8,0 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	f(arr, sz);
//	pri(arr, sz);
//
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////













//////////////////////////////////////////////////////////////////////////////////////////////////////
////////1716. 计算力扣银行的钱
////////Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。
////////最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。
////////给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。
////////
////////示例 1：
////////输入：n = 4
////////输出：10
////////解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。
//////// 
////////示例 2：
////////输入：n = 10
////////输出：37
////////解释：第 10 天后，总额为(1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。
//////// 
////////示例 3：
////////输入：n = 20
////////输出：96
////////解释：第 20 天后，总额为(1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。
//#include<stdio.h>
//
//int main()
//{
//	int money = 0, sum = 0, num = 0;
//	int day;
//	scanf("%d", &day);
//	while (1)
//	{
//		int i;
//		for (i = 1; i <= 7; i++)
//		{
//			sum += (money + i);
//			num++;
//			if (num == day) {
//				break;
//			}
//		}
//		if (num == day) {
//			break;
//		}
//		money++;
//	}
//	printf("%d", sum);
//	return 0;
//}
//////////////////////////////////////////////////////////////////////////////////////////////////////



