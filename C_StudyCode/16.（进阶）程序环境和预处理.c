//#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>




 //////本章重点
////////////////////  ・程序的【翻译环境】
////////////////////  ・详解：C语言程序的编译+链接
////////////////////  ・程序的运行环境
////////////////////  ・预编译(预处理)符号介绍
////////////////////  ・预处理指令#define
////////////////////  ・预处理操作符 # 和 ## 的介绍
////////////////////  ・宏和函数的对比
////////////////////  ・预处理指令 #undef
////////////////////  ・命令行定义





//下面是代码跑起来的整个过程：

////  C代码-文本文件                                机器指令-二进制文件
////  test.c(源程序)  -------编译-----链接------->  test.exe(可执行程序) ---> 运 行
////               |     翻    译    环    境      |                   |  运  行  环  境  |



////////////////////////程序的翻译环境和执行环境
//// 
////在ANSI C(标准C语言)的任何一种实现中，都存在两个不同的环境
////第一个是【翻译环境】，在这个环境中源代码被转换为可执行的机器指令
////第二个是【执行环境】，它用于实际执行代码







 
////////////////////  ・程序的【翻译环境】
////////////////////  ・详解：C语言程序的编译+链接


//////源文件，经过编译器的【编译】处理，和链接器的【链接】处理，生成可执行程序
// 
//・【编译】：组成一个程序的的每个源文件(.c)都会经过【编译器】处理，分别转换成目标文件(.obj)。  -- object 目标,对象
//          *（编译作用）：把每个文件的C语言转化为机器语言(二进制)
// 
//・【链接】：每个目标文件(.obj)，再加上一个链接库，经过【链接器(linker)】的处理，形成单一完整的可执行程序(.exe)。  --executable 可执行的
// 注意：连接器会同时引入标准C函数库中任何被该程序所用到的函数，而且它可以搜索程序员的个人程序库，将其需要的函数也链接到程序中。
//          *（链接作用）：把所有文件中的机器语言汇总到一个文件中



////以下为详细解读：

////*【编译】又分为三个阶段：【预编译/预处理】、【编译】、【汇编】
// 
// 
//////【预编译/预处理】：对test.c文件进行【文本操作】，生成test.i文件，具体如下       -----------------------------     【本章重点】
////         （文本操作）1.#include - 头文件的包含（把头文件展开，还原为C库中代码）
////                     2.注释删除 - 使用空格替换注释
////                     3.#define -  替换为对应的数值
// 
//////【编译】：把test.i的【C语言代码翻译为汇编代码】，生成test.s文件
////   （C代码翻译为汇编代码）1.语法分析
////                          2.词法分析 - 《编译原理》
////                          3.语义分析
////                          4.符号汇总
// 
//////【汇编】：把test.s的【汇编代码转换为二进制代码】，生成目标文件test.o (.obj)
////   （汇编代码转换为二进制代码）1.形成符号表
////                               2.汇编指令->二进制指令



////*【链接】
////1.合并段表
////2.符号表的合并和重定位






////////////////////  ・程序的运行环境


////一个程序已经形成了.exe的可执行文件，之后怎么运行起来呢？
// 
// 
////程序执行的过程：
// 
////1.程序必须载入内存中。
////      在有操作系统时：这个步骤由操作系统完成；
////      在独立环境中，程序的载入要由手工完成，也可能是通过可执行代码置入只读内存来完成。
// 
////2.程序的执行便开始了。接着便调用main函数
// 
////3.开始执行代码。这个时候程序将使用栈、堆、静态内存来存储其对应的数据。
// 
////4.终止程序。正常终止程序或意外终止。




















////////////////////  ・预编译(预处理)符号介绍


//预定义符号
// __FILE__ 进行编译的源文件
// __LINE__ 这个符号当前在第几行
// __FUNCTION__ 这个符号当前在哪个函数中
// __DATE__ 文件被编译的日期
// __TIME__ 文件被编译的日期
// __STDC__ 如果编译器遵循ANSI C，其值为1，否为未定义
//
//这些预定义符号都是语言内置的，使用例子如下



//int main()
//{
//	printf("%s\n", __FILE__);//打印出该源文件的文件名(文件路径+文件名主干+文件后缀)：C:\Users\lenovo\source\repos\test - 1\test - 1\16.（进阶）程序环境和预处理.c
//	printf("%d\n", __LINE__);//打印出了这一行的标号：152
//	printf("%s\n", __FUNCTION__);//打印出了现在所在的函数：main
//	printf("%s\n", __DATE__);//打印出了文件编译的日期：Dec 12 2022
//	printf("%s\n", __TIME__);//打印出了文件编译的时间：11:33:26
//
//	return 0;
//}



////具体使用方法:把这些标记写入文件
//int main()
//{
//	int i = 0;
//	int arr[10] = { 0 };
//	FILE* pf = fopen("test.txt", "w");
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i + 1;
//		fprintf(pf, "file:%s  line:%d  date:%s  time:%s  i=%d", __FILE__, __LINE__, __DATE__, __TIME__, i);
//	}
//
//	fclose(pf);
//	pf = NULL;
//
//	return 0;
//}




















////////////////////  ・预处理指令#define
//// #define - 定义标识符/定义宏
//// 不包含变量就是标识符，包含变量就是宏



///////////////     【 #define 定义标识符 】
// 
//// 语法：#define name stuff
//
// 
// 
////以下为例子
//#define MAX  100
//#define STR  "hehe" 
//#define REG  register        //为 register 这个关键字，创建一个简短的名字
//#define do_forever  for(;;)  //用更形象的符号来替换一种实现
//#define CASE  break;case     //在写case语句的时候自动把break加上 
//
// 
//// define定义标识符常量在预编译是转化为其对应的值/表达式/语句
//// 注意，define的定义中习惯最好不要加分号，防止语法错误而不自知。要加的时候也可以加。



//#define MAX  100
//#define STR  "hehe" 
//#define REG  register       
//#define do_forever  for(;;)
//#define CASE  break;case   
//
//int main()
//{
//	printf("%d\n", MAX);//100    //在预编译时转化为对应的值
//	printf("%s\n", STR);//hehe
//	REG int a;//这种写法相当于 register int a;
//
//	do_forever; //相当于在这里放了一个 for(;;);
//
//	return 0;
//}







///////////////     【 #define 定义宏 】
//// #defint 机制包含了一个规定，允许把参数替换到文本中，这种实现通常称为宏(macro)或定义宏(define macro)
//// 命名约定：宏和函数语法相似，语言本身没法帮我们区分二者，那我们平时的一个习惯是：【宏名全部大写，函数名不要全部大写】 
//
// 
//
//// 下面是宏的声明方式
//// 【  #define name(parament-list) stuff  】     其中parament-list是一个由逗号隔开的符号表，它们可能出现在stuff中
//
//// 注意：1.参数列表的左括号必须与name紧邻。如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分
////       2.定义宏时不要吝啬括号，因为宏的运算是直接替换
////         ・加括号，避免在使用宏时，由于[参数中操作符]或[临近操作符]之间不可预料的相互作用，搅乱运算顺序。
//
//
//
//// 例如：
//// #define SQUARE(X)  ((X) * (X))
//// #define ADD(X)  ((X) + (X))
//
//
//
//// 在程序中拓展 #define 定义符号和宏时，需要涉及几个步骤
////   1.在调用时，首先多参数进行检查，看看是否包含任何由#define定义的符号。如果时，她们优先被替换。
////   2.调换文本随后被插入到程序原来文本的位置。对于宏，参数名被它们的值替换。
////   3.最后，再次对结果文件进行扫描，看看它们是否包含任何由#define定义的符号。如果是，就重复上述过程
//
//
//// 特别提醒：
//// 1.宏参数和 #define定义中可以出现其他 #define定义的变量，但对于宏，不能出现递归
//// 2.当预处理器搜索 #define定义的符号时，字符串常量的内容并不被搜索
////   就是说假定有宏ADD，但是字符串"ADD"，字符串内ADD为字符串本身的内容，不被替换




////例1：
//
//#define SQUARE(X) X*X
//#define SQUARE1(X) (X)*(X)
//
//int main()
//{
//	int ret = SQUARE(5);
//	printf("%d\n", ret);//25
//
//	//写宏的时候不要吝啬括号
//
//	int ret1 = SQUARE(5 + 1);
//	printf("%d\n", ret1);// 11  宏是在预编译的时候直接替换到当前函数内的，这里替换后变为 5 + 1*5 + 1
//
//	int ret2 = SQUARE1(5 + 1);
//	printf("%d\n", ret2);// 36  宏的声明时添加括号后，替换为 (5 + 1)*(5 + 1)
//
//	return 0;
//}



////例2：
//
//#define DOUBLE(X) (X)+(X)
//#define DOUBLE1(X) ((X)+(X))
//
//int main()
//{
//	int a = 5;
//	int ret = 10 * DOUBLE(a);
//	printf("%d\n", ret);// 55  这是因为替换为 10 * (a) + (a)
//
//	int ret1 = 10 * DOUBLE1(a);
//	printf("%d\n", ret1);// 100  这里替换为 10 * ((a) + (a))
//
//	return 0;
//}


//////写宏的时候不要吝啬括号
// 
//总结1：当【宏的参数为表达式】，当(宏参数的表达式内操作符优先级)和(宏内的操作符优先级)不同时，可能导致表达式的计算顺序发生意外
//     ・定义宏时，宏的参数添加括号，将参数变成独立的部分，明确的指定计算顺序。
//总结2：当【宏在表达式中时】，当(宏所在的表达式中操作符优先级)和(宏内的操作符优先级)不同时，也可能影响运算结果
//     ・定义宏时，宏整体添加括号，防止替换后宏以外操作符影响宏内结果







///////////  【百度面试题目】模拟实现offsetof  -- 【offsetof( 结构体类型名 , 成员名 ) - <stddef.h>】
///////////  请编写宏，计算结构体中某变量相对于首地址的偏移量
//
// 
//#include<stddef.h>
//
//struct S
//{
//	char c1;
//	int a;
//	char c2;
//};
//
//#define MY_OFFSETOF(struct_name,member_name) (int)(&(((struct_name*)0)->member_name))
//
//int main()
//{
//	printf("%d\n", offsetof(struct S, c1));//0
//	printf("%d\n", offsetof(struct S, a));//4
//	printf("%d\n", offsetof(struct S, c2));//8
//	puts("");
//	printf("%d\n", MY_OFFSETOF(struct S, c1));//0
//	printf("%d\n", MY_OFFSETOF(struct S, a));//4
//	printf("%d\n", MY_OFFSETOF(struct S, c2));//8
//
//	return 0;
//}
//
//
//
//// 这是宏offsetof的模拟实现：
//// #define MY_OFFSETOF(struct_name,member_name) (int)(&(((struct_name*)0)->member_name))
//// 
//// 原理如下：
//// 【偏移量 = 成员地址 - 结构体起始地址】
//// 【若结构体起始地址为0，那么成员地址即为偏移量】
//// 偏移量的值为：(int)(&(((struct_name*)0)->member_name))
//// 
//// 解析： 
//// (struct_name*)0，把0强转为结构体指针的值，代表这个结构体在0地址处
//// (struct_name*)0)->member_name，结构体指针指向成员名，找到想要寻找的成员
//// &(((struct_name*)0)->member_name)，取该出成员的地址，由于起始地址为0，成员地址即该成员偏移量
//// (int)(&(((struct_name*)0)->member_name))，把成员地址强制转化为(int)型，即为偏移量











/////////////////////  ・带副作用的宏参数
////// 当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，由于宏是直接替换，在使用这个宏的时候就可能出现危险，导致不可预测的结果。
////// 副作用就如a++，该操作符会使a自身的值发生改变


//#define MAX(X,Y) ((X)>(Y)?(X):(Y))
//int main()
//{
//	int a = 10;
//	int b = 11;
//	int max = MAX(a++, b++);//替换后，int max = ((a++)>(b++)?(a++):(b++))，由于参数的副作用，导致达不到想要结果
//
//	printf("%d\n", max);//12
//	printf("%d\n", a);//11
//	printf("%d\n", b);//13
//
//	return 0;
//}

















//////////////////////  ・预处理操作符 # 和 ## 的介绍



////////////////////////【 # 操作符 】(宏中使用)
//
////   #操作符 可以把一个【宏参数】变成【其对应的字符串】
////   也就是说，在宏中，#X 会被转换成 "X" 
// 
// 
////   e.g. 
////   #define PRI(X) printf(#X) -> printf("X")


//宏中使用#X就可以将变量参数打印出来，而函数做不到这一点
//#define PRI(X) printf("the value of" #X "is %d\n",X)
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//
//	PRI(a);//the value of a is 10
//           //宏参数是a，替换为："the value of "#a" is %d\n" == "the value of " "a" " is %d\n"
// 
//	PRI(b);//the value of b is 20
//           //宏参数是b，替换为："the value of "#b" is %d\n" == "the value of " "b" " is %d\n"
//
//	return 0;
//}






////////////////////////【 ## 操作符 】(宏中使用)
//
////   #3操作符 可以把位于它两边的符号合成一个符号。它允许宏定义从分离的文本片段创建标识符
////   也就是说，在宏中，X##Y 会被转换成 XY(有效符号) 
//
///    注意： 这样的连接必须产生一个合法的标识符，否则其结果就是未定义的
// 
// 
////   e.g. 
////  #define A(X,Y) X##Y -> XY


//#define A(X,Y) X##Y
//
//int main()
//{
//	int abc123 = 100;
//	printf("%d\n", A(abc, 123));//100  这里把两个宏参数abc 123合成了abc123
//
//	return  0;
//}





















////////////////////  ・宏和函数的对比 

////宏常被运用于【简单的运算】，比如在两个数中比较大小
////#define MAX(X,Y) ((X)>(Y)?(X):(Y))
// 
// 
////为什么不用函数来完成这个任务？
////1.用于[调用函数]和[从函数返回]的代码可能你实际执行这个小型计算工作所需要的时间更多。
////  所以【宏比函数在程序的规模和速度方面更胜一筹】。
// 
////2.更为重要的时函数的参数必须声明为特定类型。所以函数只能在类型合适的表达式上使用。
////  反之这个宏可以使用于整型、长整型、浮点型等可用于比较的类型。【宏的参数类型随意】
//
//
//int Max(int x, int y){
//	return(x > y ? x : y);
//}
//#define MAX(X,Y) ((X)>(Y)?(X):(Y))
//int main()
//{
//	int a = 20, b = 10;
//	int max1 = Max(a, b);//函数传参必须是特定的类型
//	printf("%d\n", max1);
//	//函数在调用的时候，会有调用和返回的系统开销
//
//
//	int max2 = MAX(a, b);//预处理阶段完成了替换
//	printf("%d\n", max2);
//
//	return 0;
//}
//
//
////当然宏也有劣势的地方：
////1.【每次使用宏的时候，一份宏定义的代码将插入程序中。除非宏比较短，否则可能大幅度增加程序的长度】。
////2.宏是没法调试的。
////3.宏参数由于类型无关，也不够严谨
////4.宏可能带来运算优先级的问题，导致容易出错。



////宏有的时候可以做到函数绝对做不到的事情，比如：【宏的参数可以出现类型】，但是函数做不到
//
//#define MALLOC(num,type) (type*)malloc(num*sizeof(type))
//int main()
//{
//	int* p1 = (int*)malloc(10 * sizeof(int));
//	int* p2 = MALLOC(10, int);//宏参数可以传递类型，转换后和p1完全相同
//
//	return 0;
//}






////////  重点：【宏和函数的区别】
//
////【代码长度】
//// 宏：每次使用时，宏代码都会插入程序中，出来非常小的宏之外，程序的长度会大幅增长
//// 函数：函数的代码在翻译后仍只有一段；每次使用这个函数，都调用那个地方的同一段代码
// 
////【执行速度】
//// 宏：更快
//// 函数：存在函数的调用和返回的额外开销，所以相对慢一些
// 
////【操作符优先级】
//// 宏：宏参数的求值实在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料后果。所以宏的书写建议多加括号
//// 函数：函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测
// 
////【带有副作用的参数】
//// 宏：参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果
//// 函数：函数传参只在传参的时候求值一次，结果更容易控制
// 
////【参数类型】
//// 宏：宏的参数与类型无关。只要对参数的操作是合法的，它就可以使用任何参数
//// 函数：函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是相同的
// 
////【调试】
//// 宏：宏是不能调试
//// 函数：函数是可以退逐语句、逐过程调试的
// 
////【递归】
//// 宏：宏不能递归
//// 函数：函数可以递归
// 





















////////////////////  ・预处理指令 #undef 
////这条指令用于移除一个宏定义


//#define MAX 100
//
//int main()
//{
//	printf("%d\n", MAX);
//
//	//移除一个宏定义
//#undef MAX;
//
//    //printf("%d\n", MAX);//“MAX”: 未声明的标识符
//	return 0;
//}





















////////////////////  ・命令行定义 
 
//许多编译器提供了一种能力，允许在命令行中定义符号，用于启动编译过程。
//例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本时，这个特性就有用处了
//（假定某个程序中声明了某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一个机器内存较大，我们需要一个数组能够大一些，就可用命令行定义数组的大小）
//Windows系统不好演示，其他系统如Linux下才能使用





















////////////////////  ・条件编译 
////// 预处理指令中有条件编译指令
//
// 
////// 在编译一个程序的时候，我们如果【要将一条(一组)语句编译或者放弃】是很方便的，因为我们有【条件编译指令】。
////// 调试性的代码，保留碍事，删除可惜，使用我们可以选择性的编译



////有很多种条件编译格式，以下为例子：
// 
//////格式1：
//// 
////#ifdef SYMBOL//SYMBOL - 标识符名称
////    //... 
////#endif
//
////如果SYMBOL定义过，就执行#indef和#endif中间的语句，否则就不执行
////#ifdef和#endif是一对，若SYMBOL定义过，那么中间的代码就参与编译(预编译阶段保留这段代码)；
////                      若SYMBOL未定义，就不参与编译(预编译阶删除这段代码)
//
//
////#ifndef SYMBOL//和上面相反，如果not定义，就执行中间的语句
////    //... 
////#endif


////例子如下
//#define DEBUG//条件编译，只要这个标识符定义就可以，不用赋值也行
//int main()
//{
//	int arr[10] = { 0 };
//	int i = 0;
//	for (i = 0; i < 10; i++)
//	{
//		arr[i] = i + 1;
//
//#ifdef DEBUG//#ifdef和#endif是一对，意思是如果DEBUG定义过，那么中间的代码就参与编译(预编译阶段保留这段代码)；若DEBUG没定义过，就不参与编译(预编译阶删除这段代码)
//		printf("%d ", arr[i]);
//#endif
//	}
//
//	return 0;
//}






////// 格式2：
////
////#if 常量表达式
////    //...
////#endif
////
//// 常量表达式由预处理器求值。
//// 若常量表达式为真，就执行中间的语句





////// 格式3：
////// 多个分支的条件编译   
////
////#if 常量表达式
////    //...
////#elif 常量表达式
////    //...
////#else
////    //...
////#endif    
////
//// 若常量表达式为真，就执行中间的语句





////// 格式4：（等价于格式1）
////// 判断是否被定义 
////
////#if defined(SYMBOL)//SYMBOL - 标识符名称
////    //...
////#endif
////
////若标识符被定义，编译中间的语句
////注意：这种写法  【#if defined(SYMBOL) == #ifdef SYMBOL】
//
//
////#if !defined(SYMBOL)
////    //...
////#endif
///
///假如为定义标识符，就编译中间的语句
////注意：这种写法  【#if !defined(SYMBOL) == #ifndef SYMBOL】





////// 格式5：
////// 嵌套指令 
//// 
//// 
////#if defined(OS_UNIX)
////      #ifdef OPTION1
////            unix_version_option1();
////      #endif
////      #ifdef OPTION2
////            unix_version_option2();
////      #endif
////#elif defined(OS_MSDOS)
////      #ifdef OPTION2
////            msdos_version_option2();
////      #endif
////#endif  
////
//// 
//// 类比if，语句的嵌套
//// 在官方头文件中很常见























////////////////////  ・预处理指令 #include

//我们已经知道，#include 指令可以使另一个文件被编译，就像那个文件实际出现在与 #include 指令的地方应用。
//这种替换的方式很简单：【预处理器先删除这条指令，并用包含文件的内容替换】。
//这样一个源文件被包含10次，那就实际被编译10次，这段代码也会在目标文件.obj中重复10次。


//// 【本地文件包含】
//// #include "filename.h"//【双引号】
//
////查找策略：1先在源文件所在的目录下查找;
////          2如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置找头文件;
////          3如果找不到就提示编译错误。
//
// 
//// 所以，对于库文件也可以使用双引号 "" 的形式包含。
//// 但是这样做效率低且不易区分是库文件还是本地文件。



//// 【库文件包含】
//// #include <filename.h>//【尖括号】
//
////查找策略：直接去标准路径下去查找，如果找不到就提示编译错误








////// ・头文件有时由于失误会导致重复多次被包含，解决办法如下


////// 【法1：】
////// 假设下面这段代码在头文件test.h中
//
//#ifndef __TEST_H__//若标识符__TEST_H__未被定义
//#define __TEST_H__
//int Add(int a, int b);
//#endif
//
// 
//// 上面这段精妙的代码的意思为：
//// 如果__TEST_H__未被定义，进入语句，定义__TEST_H__。若之后再次引这个头文件，__TEST_H__已经被定义，就不进入语句。



////// 【法2：】
////// 假设下面这段代码在头文件test.h中
//
//#pragma once
//int Add(int a, int b);
//
//
//// 每个头文件中都有这段代码
//// 这段代码是比较现代的写法，能让头文件只被包含一次，避免被多次引入




















// #开头都是预处理指令，在预处理阶段生效
// #define
// 条件编译指令 #ifdef #endef / #if #elif #endif
// #include
// ...
//////////////////////////  ・其他预处理指令
// 
// #error
// #pragma
// #line
// ...
// 
////想要了解 - 《C语言深度解剖》




