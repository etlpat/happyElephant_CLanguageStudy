//#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>
//#include<stdlib.h>
//#include<string.h>
//#include<errno.h>






//// 本章重点：
//////  为什么存在动态内存分配
//////  动态内存函数的介绍
////      malloc
////      free
////      calloc
////      realloc
//////  常见的动态内存错误
//////  几个经典的笔试题
//////  柔性数组










////////////////////////  为什么存在动态内存分配



////内存区域
////栈区（局部变量、函数的形式参数）
////堆区（动态内存分配）
////静态区（全局变量、静态变量(stating int a = 10)）



////////1.创建一个变量
////////局部变量 - 栈区
////////全局变量 - 静态区
////
////////2.创建一个数组
////////局部数组 - 栈区
////////全局数组 - 静态区
////
////
////////但是上述的开辟空间的方式有两个特点：
////////1.空间开辟大小是固定的
////////2.数组在声明时，必须指定数组长度，它所需要的内存在编译时分配
//
//////int main()
//////{
//////	int arr[50] = { 0 };
//////	//数组声明时，[]内元素个数必须为常量
//////	return 0;
//////}
////////C语言可以创建变长数组(声明数组时[]内放变量) - C99中增加的规则
////////但不是所有编译器都用C99标准，所以代码不能这么写




////  为什么存在动态内存分配？ 
// 
////////对于空间的需求，不仅仅是上述的情况，有时我们需要的空间大小在程序运行的时候才能知道，
////////那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态内存开辟了。（在堆上开辟空间）

















 
////////////////////////   动态内存函数的介绍 
////  malloc、free、calloc、realloc
////  头文件 <stdlib.h> 或 <malloc.h> 

//// malloc : memory(内存) + allocate(分配)
//// calloc : clear(清零) + allocate(分配)
//// realloc : re(前缀:重新) + allocate(分配)







////////////////////  malloc() 
////// 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针 
// 
////// 头文件：<stdlib.h> 或 <malloc.h> 
//////  malloc：memory(内存) + allocate(分配) 
//  
////// 声明：void *malloc( size_t size );//要申请空间的字节大小
// 
////// 返回值：如果开辟成功，则返回一个指向开辟好的空间的(void*)类型指针.
//////         如果开辟失败，即电脑内存不足以存放开辟的空间时，则返回NULL。因此malloc的返回值一定要做检查。
//////                      （比如电脑只有4G空间，该函数却想要申请8G，申请失败，返回NUll）
//////         如果参数size为0，malloc的行为是标准未定义的，取决于编译器
//
// 
////// malloc()和free成对使用()




////////////////////  free()
////// 释放和回收一个动态内存块
// 
////// 头文件：<stdlib.h> 或 <malloc.h> 
//  
////// 声明：void free( void *memblock );//要释放的内存块的首地址
// 
// 
////// free函数的行为： 
//////   free函数释放先前通过调用calloc、malloc或realloc分配的内存块(memblock)。
//////   【释放的字节数】等价于【分配内存块(或在realloc情况下重新分配)时请求的字节数】，所以free参数若不是内存的首地址，会造成【越界释放】
//////   如果要释放的内存块地址指向NULL，则忽略指针并立即跳出该函数，什么都不干。
//////   试图释放非动态开辟的指针时，free函数的行为是未定义的。（指针在栈，free释放堆）
//
//
//
////// 1.【free对内存做了什么】
//////    注意：free释放的是内存空间，而不是指针。
//////    ――【释放】，指针指向的内存空间可以被其他变量所占用，但被占用前，内存空间中的内容仍然存在，但是无法判定是否被占用。
////// 2.【free对指针做了什么】
//////    指针指向的地址，在没有重新分配内存前，也没有发生变化。
//////    free后，指针仍然指向分配的内存空间，指针指向的地址没有变化，地址内的内容也没有发生变化。
//
//
// 
////// 【野指针】:只是定义了指针指向的类型，而指针没有指向内存空间。把这样的指针叫野指针。
////// 【悬空指针】:若两个指针(p1和p2)指向同一块内存区域, 那么free(p1)后，p1和p2都成为悬空指针。
//////              如果进一步将p1设置为NULL, 那么p2还是悬空指针。
//////              使用* p1 会导致非法内存访问(NULL对应的内存不允许程序访问），但是使用* p2却会出现无法预料的结果（可能是没有释放时该位置的原始指，也可能是其他值）






//#include<stdlib.h>
//#include<string.h>
//#include<errno.h>
//
//int main()
//{
//	//向内存申请10个整型空间
//	int* p = (int*)malloc(10 * sizeof(int));
//
//	if (p == NULL)
//	{
//		//打印错误原因的一种方式
//		printf("%s\n", strerror(errno));  //这里申请失败的话，打印 Not enough space
//		//strerror--把错误码所对应的错误信息打印出来；errno--全局的错误码
//	}
//	else //空间开辟成功
//	{
//		int i = 0;
//		for (i = 0; i < 10; i++)
//		{
//			*(p + i) = i + 1;
//		}
//		for (i = 0; i < 10; i++)
//		{
//			printf("%d ", *(p + i));
//		}
//	}
//
//	//当动态申请的空间不再使用时
//	//应该把内存还给操作系统
//	free(p);
//	//指针p指向的空间被释放后，p仍然有能力找到这块空间,即p变成了[悬空指针]
//	p = NULL;//要把p赋为空指针，防止误用悬空指针，造成未知结果
//
//	return 0;
//}











////////////////////  calloc() 
////// 在内存中开辟一块的空间，将其空间中【元素初始化为0】,并返回指向这块空间的void*
// 
////// 头文件：<stdlib.h> 或 <malloc.h> 
////// calloc：clear(清零) + allocate(分配) 
//  
////// 声明：void *calloc( size_t num, size_t size );//元素个数，元素大小
// 
////// 返回值：如果开辟成功，则返回一个指向开辟好的空间的(void*)类型指针.
//////         如果开辟失败（内存不够用），则返回NULL。因此calloc的返回值一定要做检查。            
//////         如果参数size为0，malloc的行为是标准未定义的，取决于编译器
//
// 
////// calloc()也和free成对使用()



//#include<stdlib.h>
//#include<string.h>
//#include<errno.h>
//
//int main()
//{
//	//malloc(10*sizeof(int))
//	int* p = calloc(10, sizeof(int));//元素与malloc的不同
//	if (p == NULL)
//	{
//		printf("%s\n", strerror(errno));
//	}
//	else 
//	{
//		int i;
//		for (i = 0; i < 10; i++)
//		{
//			//可以看出，calloc函数将开辟空间内元素初始化为0
//			printf("%d ", *(p + i));
//		}
//	}
//
//	//释放动态开辟的空间
//	free(p);
// p = NULL;
//
//	return 0;
//}










////////////////////  realloc()  
////// 调整动态内存空间的大小 / (官方解释：重新分配内存块)
 //
////// 头文件：<stdlib.h> 或 <malloc.h> 
////// realloc：re(前缀:重新) + allocate(分配)
//  
// 
////// 声明：void *realloc( void *memblock, size_t size );
////// [memblock] 是要调整的内存块的地址
////// [size]     是调整之后内存的新大小
// 
////// [返回值]   为调整之后的内存起始位置
//
//
// 
////// 情景 1.如果p指向的空间之后【有足够大的内存可以追加】，则新增的空间【直接追加】在这块空间后面，最后返回的【地址不变】
////// 情景 2.如果p指向的空间之后【没有足够的内存空间来追加】，则realloc函数会找新的内存区域来开辟一块满足需求的空间，
//////        并且把原来内存中的【数据拷贝到新内存中】，并【自动释放旧的内存空间】，最后返回新开辟的内存空间的【新地址】
////// 情景 3.若是剩余内存【不够开辟新空间】，则开辟失败，【返回NULL】
//////       （所以为了防止之前的旧地址被NULL替代，需要先使用一个新的变量接收该函数返回值并判断是否为空指针，而不能直接赋值）
//
//
////// 需要注意：
////// 假如用calloc开辟动态空间，realloc再次调整开辟的空间大小，新添的内存不会被初始化为0
//
//
////// 补充：
////// int *p = realoc(NULL, 10 * sizeof(int));
////// realloc第一个参数直接传NULL，相当于没有提供调整空间的地方，直接重新找地方开辟新空间，作用和malloc相同




//#include<stdlib.h>
//#include<string.h>
//#include<errno.h>
//
//int main()
//{
//
//	int* p = (int*)malloc(20);
//
//
//	if (p == NULL)//判断是否开辟成功
//	{
//		printf("%s\n", strerror(errno));
//	}
//	else
//	{
//		int i = 0;
//		for (i = 0; i < 5; i++)//修改调整前的空间
//		{
//			*(p + i) = i + 1;
//		}
//	}
//	//上面只是在使用malloc开辟的20字节的空间
//
//
//	//假设这里20字节不能满足我们使用，我们希望有40个字节的空间
//	//在这里就可以使用realloc来调整动态开辟的内存
//	//
//	//realloc使用时的注意事项
//	//情景 1.如果p指向的空间之后【有足够大的内存可以追加】，则新增的空间【直接追加】在这块空间后面，最后返回的【地址不变】
//	//情景 2.如果p指向的空间之后【没有足够的内存空间来追加】，则realloc函数会找新的内存区域来开辟一块满足需求的空间，
//	//       并且把原来内存中的【数据拷贝到新内存中】，并【自动释放旧的内存空间】，最后返回新开辟的内存空间的【新地址】
//	//情景 3.若是剩余内存【不够开辟新空间】，则开辟失败，【返回NULL】
//	//      （所以为了防止之前的旧地址被NULL替代，需要先使用一个新的变量接收该函数返回值并判断是否为空指针，而不能直接赋值）
//
//	int* ptr = (int*)realloc(p, 40);//大小调整为40字节
//
//	if (ptr != NULL)//判断realloc返回值是否为NULL
//	{
//		p = ptr;
//
//		int i;
//		for (i = 5; i < 10; i++)//修改调整后的空间
//		{
//			*(p + i) = i + 1;
//		}
//
//		for (i = 0; i < 10; i++)//打印修改后的空间
//		{
//			printf("%d", *(p + i));
//		}
//
//	}
//
//	//释放动态开辟的空间
//	free(p);
//	p = NULL;
//	ptr = NULL;
//
//	return 0;
//}

















////////////////////////    常见的动态内存错误

//// 1. malloc、calloc 使用后，【判断是否返回NULL】
// 
//// 2. realloc 函数使用后，返回地址可能与原来的不同，切记【重新把realloc的返回值赋给指针】
// 
//// 3. realloc 函数使用后，创建临时变量判断【是否返回NULL】
// 
//// 4. 不要对动态开辟的空间【越界访问】
// 
//// 5. 最后记得用【free释放动态空间】，并把【悬空指针赋为NULL】
////    若忘记释放动态空间，则造成【内存泄露】，一直消耗内存
// 
//// 6. 不要对【非动态开辟的空间使用free】，这种空间释放是对[栈区空间]使用[堆区的free]操作
//
//// 7. free内要放内存空间的首地址，否则造成【越界释放】，有的时候p++改变p的值，使之不再指向首地址，会报错
////    原因是free释放的空间大小为【分配内存块(或在realloc下重新分配)时请求的字节数】
//
//// 8. 不要【对同一块空间多次释放】，会报错，free后直接把指针赋为NULL，后面的free就没用了


















////////////////////////  几个经典的笔试题



////////// 题目1.下列代码问题在哪？

//void GetMemory(char* p)
//{
//	p = (char*)malloc(100);
//}
// 
//void Test()
//{
//	char* str = NULL;
//	GetMemory(str);
//	strcpy(str, "hello warld");
//	printf(str);
//}
// 
//int main()
//{
//	Test();
//	return 0;
//}

////注意：
//////printf(str); 这种写法也是对的，相当于printf("hello world");
//////GetMemory函数中，p在堆区，出函数不销毁


////错误1：GetMemory()函数传值调用，不改变str的值，str还为NULL；导致程序崩溃
// 
////    问题在于，str传到形参中，p时str的临时拷贝，值相同，地址不同
////    若通过参数p改变它指向的空间，相当于str指向的空间被改动，这叫传址调用；
////    这里把新开辟空间的指针赋给p,并不影响str本身的值，这是传值调用
//
////错误2：没判断malloc是否返回NULL
//
////错误3：没free,内存泄露



////这里把上面的代码改正确（GetMemory也可以不传参数，返回值改成char*）
//void GetMemory(char** p)
//{
//	*p = (char*)malloc(100);
//}
//void Test()
//{
//	char* str = NULL;
//	GetMemory(&str);
//
//	if (str == NULL){
//		printf("堆区空间不足\n");
//	}
//	else{
//		strcpy(str, "hello warld");
//		printf(str);
//		free(str);
//		str = NULL;
//	}
//}
//int main()
//{
//	Test();
//	return 0;
//}









////////// 题目2.下面函数打印结果是？

//char* GetMemory()
//{
//	char p[] = "hello world";
//	return p;
//}
//
//void Test()
//{
//	char* str = NULL;
//	str = GetMemory();
//	printf(str);
//}
//
//int main()
//{
//	Test();
//	return 0;
//}

//////  所以，本题的过程是：
//////  出了GetMemory函数，数组就销毁了，地址变成野指针，非法访问，打印（烫烫烫）


//////// 经典题目：【返回栈空间地址的问题】
//////// 局部变量放在【栈区】，出了函数变量就【销毁】，指针指向的空间还回了操作系统，造成非法访问内存
//////// 【堆区和静态区】，出函数时空间【不会销毁】
//
////// 例子如下：
//
//int* test1()
//{
//	int a = 10;//栈区
//	return &a;
//}
//
//int* test2()
//{
//	int* a = (int*)malloc(sizeof(int));//堆区
//	if (a == NULL) {
//		printf("没足够的空间\n");
//	}
//	else {
//		*a = 10;
//	}
//	return a;
//}
//
//int* test3()
//{
//	static int a = 10;//静态区
//	return &a;
//}
//
//int main()
//{
//	int* a = test1();//【栈区】内存空间销毁，非法访问
//	*a = 20;
//
//	int* b = test2();//【堆区】该写法正确
//	*b = 20;
//	free(b);
//	b = NULL;
//
//	int* c = test3();//【静态区】该写法正确
//	*c = 20;
//
//	return 0;
//}








////////// 题目3. 运行test会出现什么结果？

//void GetMemory(char** p, int num)
//{
//	*p = (char*)malloc(num);//内存在堆区，出函数不销毁
//}
//
//void Test()
//{
//	char* str = NULL;
//	GetMemory(&str, 100);
//	strcpy(str, "hello");
//	printf(str);
//}
//
//int main()
//{
//	Test();
//	return 0;
//}

//// 问题：内存泄露、未判断是否未NULL








////////// 题目4. 代码结果是什么？

//void Test()
//{
//	char* str = (char*)malloc(100);
//	strcpy(str, "hello");
//	free(str);
//	if (str != NULL)
//	{
//		strcpy(str, "world");
//		printf(str);
//	}
//}
//
//int main()
//{
//	Test();
//	return 0;
//}

////  输出world，但是free已经释放了空间，str为悬空指针，strcpy属于非法访问
////  而且没判断mallic是否返回NULL，最后没把free释放后的悬空指针置为NULL

















////////////////////////  C/C++程序的内存开辟


////////////       #内存图# 如下
////////////
////////////      【内核空间】（用户的代码不能读写）
////////////      【栈】（向下增长）
////////////      【内存映射段】（文件映射、动态库、匿名映射）
////////////      【堆】（向上增长）
////////////      【数据段（= 静态区）】（全局变量、静态数据）
////////////      【代码段】（可执行代码/只读常量）


////////// 1.栈区（stack）：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
//////                      栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
//////                      栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
//////
////////// 2.堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS(操作系统) 回收。分配方式类似于链表。
//////
////////// 3.数据段（静态区）（static）：存放全局变量、静态数据。程序结束后由系统释放。
//////
////////// 4.代码段：存放函数体（类成员函数和全局函数）的二进制代码






////e.g.
// 
//int globalVar/*【静态区】*/ = 1;
//static int staticglobalVar/*【静态区】*/ = 1;
//
//void Test()
//{
//	static int staticVar/*【静态区】*/ = 1;
//	int LocalVar/*【栈】*/  = 1;
//	int num1[10]/*【栈】*/  = {1,2,3,4};
//	char char2[]/*【栈】*/  = "abcd";/*【代码段】*/
//	char* pChar3/*【栈】*/  = "abcd";/*【代码段】*/
//	int* ptr1   /*【栈】*/  =  (int*)malloc(4 * sizeof(int))/*【堆】*/;
//	int* ptr2   /*【栈】*/  =  (int*)calloc(4, sizeof(int));/*【堆】*/;
//	int* ptr3   /*【栈】*/  =  (int*)realloc(ptr2, 8 * sizeof(int));/*【堆】*/;
//
//	free(ptr1); 
//	free(ptr2);
//	ptr1 = NULL;
//	ptr2 = NULL;
//	ptr3 = NULL;
//}
////注意，例如 int* ptr1 = (int*)malloc(4 * sizeof(int)); 变量ptr1存储在栈，malloc开辟的空间存储在堆


////从上面内存图和例子，就可以理解[用static关键字修饰局部变量]的例子了
//// 
////实际上普通的局部变量是在【栈区】分配空间的，栈区的特点是在上面创建的变量出了作用域就销毁。
////但是被static修饰的变量存放在【数据段（静态区）】，数据段的特点是在上面创建变量，知道程序结束才销毁，所以生命周期变长。






















////////////////////////  柔性数组（需搭配结构体使用）
//////  概念：C99 中，结构体的最后一个元素允许是未知大小的数组，这就叫做【柔性数组】成员。
//
//
////// 柔性数组的特点：
////// ・结构体中的柔性数组成员必须是最后一个，且前面必须至少有一个其他成员
////// ・sizeof返回的这种结构体大小不包括柔性数组的内存
////// ・包含柔性数组成员的结构体用malloc()函数进行的动态分配，并且分配的内存应该大于结构体的大小，以适应柔性数组的预期大小
//////   不能用calloc是因为calloc的参数不合适，void *calloc( size_t num, size_t size );



//////// 柔性数组的创建（在结构体中定义）
// 
//struct S
//{
//	int n;
//	//......
//	int arr[];//未知大小的【柔性数组成员】-数组大小可调整
//};
// 
//struct S2
//{
//	int n;
//	int arr[0];//或者这种也和上面表示是意义相同，【柔性数组成员】-数组大小可调整
//};
// 
//int main()
//{
//	printf("%d\n", sizeof(struct S));//sizeof计算结构体大小时，不包括柔性数组成员的大小	
//	return 0;
//}








////////// 柔性数组的基本应用
// 
////// 方案1：柔性数组
//
//struct S
//{
//	int n;
//	int arr[];//柔性数组
//};
//
//void pri(struct S* ps, int n)//打印函数
//{
//	printf("%d  ", ps->n);
//	int i;
//	for (i = 0; i < n; i++)
//	{
//		printf("%d ", (ps->arr)[i]);
//	}
//}
//
//int main()
//{
//	int num = 5;
//	int old_num;
//
//	//首先在堆区创建结构体，柔性数组有5个成员
//	struct S* ps = (struct S*)malloc(sizeof(struct S) + num * sizeof(int));
//	if (ps == NULL)
//	{
//		printf("创建时空间不足\n");
//	}
//	else
//	{
//		ps->n = 100;
//
//		int i = 0;
//		for (i = 0; i < num; i++)
//		{
//			(ps->arr)[i] = i + 1;
//		}
//		pri(ps, num);
//		puts("");
//
//		old_num = num;
//		num = 10;
//
//		//用realloc函数 调整柔性数组大小（为了保证结构体内存连续型，调整柔性数组必须连整个结构体一起调整，否则报错）
//		struct S* ptr = (struct S*)realloc(ps, sizeof(struct S) + num * sizeof(int));
//		if (ptr == NULL)
//		{
//			printf("调整时空间不足\n");
//		}
//		else
//		{
//			ps = ptr;
//			for (i = old_num; i < num; i++)
//			{
//				(ps->arr)[i] = i + 1;
//			}
//			pri(ps, num);
//		}
// 
//		//释放空间
//		free(ps);
//		ps = NULL;
//		ptr = NULL;
//	}
//
//	return 0;
//}




//////// 想要达到上面柔性数组的效果，也可以这么创建结构体
//
////// 方案2：结构体中成员为动态数组的指针
//
//struct S
//{
//	int n;
//	int* arr;
//};
//
//void pri(struct S* ps, int n)//打印函数
//{
//	printf("%d  ", ps->n);
//	int i;
//	for (i = 0; i < n; i++)
//	{
//		printf("%d ", (ps->arr)[i]);
//	}
//}
//
//int main()
//{
//	int num = 5;
//	int old_num;
//
//	struct S* ps = (struct S*)malloc(sizeof(struct S));
//	if (ps == NULL)
//	{
//		printf("创建时空间不足\n");
//	}
//	else
//	{
//		ps->arr = (int*)malloc(num * sizeof(int));
//
//		if (ps->arr == NULL)
//		{
//			printf("创建时空间不足\n");
//		}
//		else
//		{
//			ps->n = 100;
//
//			int i = 0;
//			for (i = 0; i < num; i++)
//			{
//				(ps->arr)[i] = i + 1;
//			}
//			pri(ps, num);
//			puts("");
//
//			old_num = num;
//			num = 10;
//
//			//调整数组大小
//			int* ptr = (int*)realloc(ps->arr, num * sizeof(int));
//			if (ptr == NULL)
//			{
//				printf("调整时空间不足\n");
//			}
//			else
//			{
//				ps->arr = ptr;
//				for (i = old_num; i < num; i++)
//				{
//					(ps->arr)[i] = i + 1;
//				}
//				pri(ps, num);
//			}
//
//			//释放空间
//          //（这里有释放先后的问题，必须先释放ps->arr，后释放ps)
//          //（若先释放ps，就不能通过结构体找到ps->arr了）
//			free(ps->arr);
//			ps->arr = NULL;
//			free(ps);
//			ps = NULL;
//			ptr = NULL;
//		}
//	}
//	return 0;
//}



//////  上面两种方案区别在于内存布局不同：
//////  方案1：结构体最后一个成员是动态数组，结构体的内存中包含了数组
//////  方案2：结构体内只存放动态数组的指针 ，结构体和数组的内存在两块区域中
//
//
//
//////  【柔性数组】（方案1）相比于普通法（方案2）的【优点】：
// 
//////   1.方便内存释放
//////   （方案1）柔性数组能一次性开辟动态空间，free的次数也少了；（方案2）开辟两次动态内存，且多次free还有释放先后的问题，错误率增加
// 
//////   2.减少内存碎片，提高空间利用率 
//////   （方案1）开辟连续空间，（方案2）malloc次数多，空间不连续，内存碎片多，空间利用率低。
//////   【内存碎片】即两块被占用空间中的可用空间，降低空间利用率
//
//////   3.提高内存访问速度 
//////    柔性数组空间连续效率更高：由于局部性原理，若内存连续，直接一次性就把数据从内存传递寄存器中，效率高。
//////    若内存不连续，则cpu在寄存器中不能一次性找到数据，就会往更低级的存储结构依次寻找，效率低







////存储结构：（越靠上，空间越小，速度越快）
// 
////寄存器
////告诉缓存
////内存
////硬盘
//
//// 计算机处理数据原理：cpu访问速度飞快，但从内存中读取的速度慢，所以读取时，计算机会把数据从【低级存储结构传递到高级存储结构】
//// 数据从低级存储结构传递到高级存储结构时，遵循【局部性原理】，会一次性把【连续的内存】传递到高级的存储结构中。
////                                             【局部性原理】：从内存中访问数据时，80%概率接着访问其周边的数据


